---
title: "Antarctic Whale Project: Single Species"
author: "Ben Weinstein"
date: "`r Sys.time()`"
output: 
  html_document:
    keep_md: true
    number_sections: true
    toc: true
    theme: spacelab
---

```{r,warning=FALSE,message=FALSE,echo=FALSE}
library(knitr)
opts_chunk$set(echo=F,warning=F,message=F,fig.width = 10,fig.height = 6)
library(boot)
library(raster)
library(reshape2)
library(ggplot2)
library(survival)
library(MASS)
library(ggmap)
library(dplyr)
library(chron)
library(gridExtra)
library(stringr)
library(R2jags)
library(move)

#New model to be run, flag turned off if just updating.
newModel<-TRUE
```

```{r,eval=F}
#Load in data
load("SingleSpecies.RData")
#jags$recompile()
newModel<-F
```

#Abstract

```{r}
mdat<-read.csv("InputData/FullData-550793189439001813.csv")

##need to look into making into a movebank object.

#Create a oceandepth in km 
mdat$ocean<-mdat$ETOPO1.Elevation*-1 / 1000

#standardize column names to match the simulation
#Create an animal tag.
mxy <- as(mdat, "data.frame")
mxy$Animal<-mxy$individual.local.identifier
mxy$x<-mxy$location.long
mxy$y<-mxy$location.lat

#grab two animals
mxy<-mxy[mxy$Animal %in% c("131132","112737","131156","12326","123232","112705","154187","121210","131134","131141","112701","131159","131117","112692","112703","121211"),]

mxy$Animal<-as.numeric(as.factor(mxy$Animal))
```

#Descriptive Statistics
```{r}
#no distance to coast,elevation
mxy<-mxy[!mxy$ETOPO1.Elevation>0,]
```

```{r}
#Plot
pp<-c(mean(mxy$x),mean(mxy$y))
m <- get_map(location=pp,source="google",zoom=4,scale=2,maptype="satellite")
ggmap(m)+geom_path(data=mxy, aes(x=x, y=y,col=as.factor(Animal)),size=.5) + labs(col="Whale")
```

##Distance

```{r,fig.height=5}
moved<-move(x=mxy$x,y=mxy$y,time=as.POSIXct(mxy$timestamp),proj=CRS("+proj=longlat +ellps=WGS84"),animal=mxy$Animal,data=as.data.frame(mxy),sensor=mxy$Animal)
dstat<-melt(move::distanceSummary(moved))
ggplot(dstat,aes(value)) + geom_histogram() + facet_wrap(~variable,scales="free")
```

##Time 
```{r,fig.height=4}
tstat<-move::timeSummary(moved)
tstat<-melt(tstat,measure.vars=colnames(tstat[[1]]))
ggplot(tstat,aes(value)) + geom_histogram() + facet_wrap(~variable,scales="free")
```

##Velocity
```{r,fig.height=3}
vstat<-move::speedSummary(moved)
vstat<-melt(vstat,measure.vars=colnames(vstat[[1]]))
ggplot(vstat,aes(value)) + geom_histogram() + facet_wrap(~variable,scales="free")
```

##Angles

```{r,fig.height=3}
astat<-move::angleSummary(moved)
astat<-melt(astat,measure.vars=colnames(astat[[1]]))
ggplot(astat,aes(value)) + geom_histogram() + facet_wrap(~variable,scales="free")
```

#Correlated random walk

*Process Model*

$$ d_{t} \sim T*d_{t-1} + Normal(0,\Sigma)$$
$$ x_t = x_{t-1} + d_{t} $$

## Parameters

For each individual:

$$\theta = \text{Mean turning angle}$$
$$\gamma = \text{Move persistence} $$

For both behaviors process variance is:
$$ \sigma_{latitude} = 0.1$$
$$ \sigma_{longitude} = 0.1$$

##Behavioral States

$$ \text{For each individual i}$$
$$ Behavior_1 = \text{traveling}$$
$$ Behavior_2 = \text{foraging}$$

$$ \alpha_{i,1,1} = \text{Probability of remaining traveling when traveling}$$
$$\alpha_{i,2,1} = \text{Probability of switching from feeding to traveling}$$

$$\begin{matrix}
  \alpha_{i,1,1} & 1-\alpha_{i,1,1} \\
  \alpha_{i,2,1} & 1-\alpha_{i,2,1} \\
\end{matrix}
$$

##Environment

Behavioral states are a function of local environmental conditions. The first environmental condition is ocean depth. I then build a function for preferential foraging in shallow waters.

It generally follows the form, conditional on behavior at t -1:

$$Behavior_t \sim Multinomial([\phi_{traveling},\phi_{foraging}])$$
$$logit(\phi_{traveling}) = \alpha_{Behavior_{t-1}} + \beta_1 * Ocean_{y[t,]}$$
$$logit(\phi_{foraging}) = \alpha_{Behavior_{t-1}} + \beta_2 * Ocean_{y[t,]}$$

```{r,fig.height=3,fig.width=3.5}
dplot<-function(a1,beta,x){
  y<-inv.logit(a1[1]+beta[1]*x)
  d11<-data.frame(x,y,State="Traveling",Begin="Traveling")
  
  y<-1-inv.logit(a1[1]+beta[1]*x)
  d12<-data.frame(x,y,State="Feeding",Begin="Traveling")

  y<-inv.logit(a1[2]+beta[2]*x)
  d21<-data.frame(x,y,State="Traveling",Begin="Feeding")
  
  y<-1-inv.logit(a1[2]+beta[2]*x)
  d22<-data.frame(x,y,State="Feeding",Begin="Feeding")
  
  d<-rbind_all(list(d11,d12,d21,d22))
}
```


##Continious tracks

The transmitter will often go dark for 10 to 12 hours, due to weather, right in the middle of an otherwise good track. The model requires regular intervals to estimate the turning angles and temporal autocorrelation. As a track hits one of these walls, call it the end of a track, and begin a new track once the weather improves. We can remove any micro-tracks that are less than three days.
Specify a duration, calculate the number of tracks and the number of removed points. Iteratively.

```{r}

##Time is the beginning of the first point.
step_length=6

sxy<-split(mxy,mxy$Animal)

#time diff function
timed<-function(d,step_length){
  d$j[1]<-0
  for (x in 2:nrow(d)){
    d$j[x]<-as.numeric(difftime(as.POSIXct(d$timestamp[x]),as.POSIXct(d$timestamp[x-1]),units="mins"))/(step_length*60)
  }
  
  #Split out track endings
  ends<-c(1,which(d$j>1),nrow(d))

  for(w in 2:length(ends)){
    d[ends[w-1]:ends[w],"Track"]<-w-1
  }
  
  #remove tracks that are shorter than three days
  track_time<-d %>% group_by(Track) %>% summarize(mt=difftime(max(as.POSIXct(timestamp)),min(as.POSIXct(timestamp)),units="days")) %>% filter(mt>3) %>% .$Track

  
  d<-d[d$Track %in% track_time,]
  
  #renumber the tracks
  d$Track<-as.numeric(as.factor(d$Track))
  return(d)
  }

sxy<-lapply(sxy,timed,step_length=6)

#Format matrices for jags
mxy<-rbind_all(sxy)

######recode whales
mxy$Animal<-as.numeric(as.factor(mxy$Animal))

sxy<-split(mxy,list(mxy$Animal,mxy$Track),drop=TRUE)

sxy<-lapply(sxy,function(x){
#How many observations in each step length segment
x$Step<-as.numeric(cut(as.POSIXct(x$timestamp),"6 hours"))
return(x)
})

mxy<-rbind_all(sxy)
```

```{r}
#total number of steps per track/animal
steps_all<-mxy %>% group_by(Animal,Track) %>% summarize(n=length(unique(Step)))

# give each step a label
mxy<-mxy %>% group_by(Animal,Track,Step) %>% mutate(jStep=1:n())

#Cast time array
j<-acast(mxy,Animal~Track~Step~jStep,value.var="j")

#how many observations per individual in each Step
mxy$Step<-factor(mxy$Step,levels=1:max(steps_all$n))
idx<-melt(table(mxy$Animal,mxy$Track,mxy$Step))
colnames(idx)<-c("Animal","Track","Step","jStep")
idx<-acast(data=idx,Animal~Track~Step)

#make ocean a matrix -> MEAN VALUE -> will this yield a jags error on empty cells?
oc<-acast(mxy,Animal~Track~Step,value.var="ocean",fun.aggregate = mean)

#Individuals
ind=length(unique(mxy$Animal))

#tracks per indivudal
tracks<-mxy %>% group_by(Animal) %>% summarize(tracks=length(unique(Track))) %>% .$tracks

#steps per track
steps<-acast(steps_all,Animal~Track,value.var="n")

#obs array
obs<-melt(mxy,measure.vars=c("x","y"))
obs<-acast(obs,Animal~Track~Step~jStep~variable)

```

How did the filter change the extent of tracks?

```{r}
#Plot
mxy<-mxy %>% arrange(Animal,Track,Step,jStep)

pp<-c(mean(mxy$x),mean(mxy$y))
m <- get_map(location=pp,source="google",zoom=4,scale=2,maptype="satellite")
ggmap(m)+geom_path(data=mxy, aes(x=x, y=y,col=as.factor(Animal)),size=.5) + labs(col="Whale")
```

```{r,fig.height=4,fig.width=6}
ggplot(data=steps_all,aes(x=n*step_length/24)) + geom_histogram() + labs(x="Days") + ggtitle("Track Length")
ggplot(data=steps_all,aes(x=Track)) + geom_histogram() + labs(x="Subtracks per Animal")
```

```{r,eval=T}
#source model
source("Bayesian/MultiSpecies.R")

#print model
print.noquote(readLines("Bayesian/MultiSpecies.R"))

#prior cov shape
R <- diag(c(1,1))
data=list(argos=obs,steps=steps,R=R,ocean=oc,ind=ind,j=j,idx=idx,tracks=tracks)

#paramters to track
pt<-c("theta","gamma","phi","lalpha_mu","lbeta_mu","state")

if(newModel){
  system.time(jagM<-jags.parallel(model.file = "Bayesian/Multi_RW.jags",data=data,n.chains=2,parameters.to.save=pt,n.iter=10000,n.burnin=8500,n.thin=3,DIC=FALSE))
}

```

##Chains
```{r,fig.height=10}
#bind chains
pc<-melt(jagM$BUGSoutput$sims.array)
colnames(pc)<-c("Draw","chain","par","value")

#extract parameter name
pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]

#Extract index
splitpc<-split(pc,pc$parameter)

#single index
splitpc[c("lalpha_mu","lalpha_tau","lbeta_mu","lbeta_tau","gamma","theta")]<-lapply(splitpc[c("lalpha_mu","lalpha_tau","lbeta_mu","lbeta_tau","gamma","theta")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Behavior=sv)
    return(pc)
})

#State index
splitpc[c("state")]<-lapply(splitpc[c("state")],function(x){
    #As matrices
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+)]"))[,3:5]
    colnames(sv)<-c("Animal","Track","step")
    pc<-data.frame(x,sv)
})

#Three index
splitpc[c("phi")]<-lapply(splitpc[c("phi")],function(x){
#As matrices
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+),(\\d+)]"))[,3:6]
    colnames(sv)<-c("Animal","Track","step","Behavior")
    pc<-data.frame(x,sv)
})

#bind all matrices back together
pc<-rbind_all(splitpc)
rm(splitpc)

#plot all but phi and state
ggplot(pc[!pc$parameter %in% c("phi","state"),],aes(x=Draw,y=value)) + facet_wrap(~par,scales="free",ncol=2) + geom_line(aes(col=as.factor(chain))) + labs(col="Chain")

```

```{r}
#Plot
ggplot(data=pc[!pc$parameter %in% c("phi","state"),],aes(x=value)) + geom_histogram() + facet_wrap(~par,scales='free',ncol=4) + theme_bw()  + ggtitle("Estimated parameters, true values in red")
```

###Compare to priors

```{r}
#add comparison to priors
todraw<-table(pc$par)[1]
pc$Estimate<-"Posterior"

#add priors
#alpha
a1prior<-data.frame(Draw=1:todraw,par='alpha[1]',value=rnorm(todraw,0,1.67),parameter='lalpha_mu',Behavior=1,Estimate="Prior")

a2prior<-data.frame(Draw=1:todraw,par='alpha[2]',value=rnorm(todraw,0,1.67),parameter='lalpha_mu',Behavior=2,Estimate="Prior")

beta1prior<-data.frame(Draw=1:todraw,par='beta[1]',value=rnorm(todraw,0,1.67),parameter='lbeta_mu',Behavior=1,Estimate="Prior")

beta2prior<-data.frame(Draw=1:todraw,par='beta[2]',value=rnorm(todraw,0,1.67),parameter='lbeta_mu',Behavior=2,Estimate="Prior")

gamma1prior<-data.frame(Draw=1:todraw,par='gamma[1]',value=rbeta(todraw,5,2),parameter='gamma',Behavior=1,Estimate="Prior")

gamma2prior<-data.frame(Draw=1:todraw,par='gamma[2]',value=rbeta(todraw,2,5),parameter='gamma',Behavior=2,Estimate="Prior")

prs<-rbind_all(list(a1prior,a2prior,beta1prior,beta2prior,gamma1prior,gamma2prior))

prs$Behavior<-as.factor(prs$Behavior)

allp<-rbind_all(list(pc[!pc$parameter %in% c("phi"),],prs))

ggplot(allp,aes(x=Behavior,y=value,fill=Estimate)) + geom_violin() + facet_wrap(~parameter,scale="free")
rm(allp)
```

##Prediction - environmental function

```{r}
gc()
#get the posterior estimates of the env function
alphap<-cbind(pc %>% filter(par=='lalpha_mu[1]') %>% .$value,pc %>% filter(par=='lalpha_mu[2]') %>% .$value)

betap<-cbind(pc %>% filter(par=='lbeta_mu[1]') %>% .$value,pc %>% filter(par=='lbeta_mu[2]') %>% .$value)
 
postplot<-list()

for(j in 1:nrow(alphap)){
  postplot[[j]]<-data.frame(dplot(x=mxy$ocean,a1=alphap[j,],beta=betap[j,]),Iteration=j)
}

#remove large objects
rm(alphap)
rm(betap)

postplot<-rbind_all(postplot)

dsum<-postplot %>% group_by(x,Begin,State) %>% summarize(y_mean=mean(y),lower=quantile(y,0.05),upper=quantile(y,0.95))

#mean env estimate
ggplot(dsum[,]) + geom_ribbon(aes(x=x,y=y_mean,ymin=upper,ymax=lower,fill=State),alpha=0.5) + theme_bw() + labs(col="Transition",x="Ocean Depth (km)",y="Probability",fill="Transition") + facet_wrap(~Begin) 

#remove large object
rm(postplot)
gc()
```

#Behavioral Prediction

```{r}
#We just need Feeding behavior
behav_chains<-pc[pc$Behavior == 2 & pc$parameter %in% "phi",]

#arrange by time - capitalize
behav_chains$Step<-as.numeric(as.character(behav_chains$step))
behav_chains<-behav_chains %>% arrange(Step)

#Label Behaviors
behav_chains$Behavior<-as.factor(behav_chains$Behavior)
levels(behav_chains$Behavior)<-c("Traveling","Feeding")

#average phi
mean_phi<-behav_chains %>% group_by(Animal,Track,Step) %>% summarize(phi=mean(value))

mxy<-merge(mxy,mean_phi,by=c("Step","Track","Animal"))

#ensure order for plotting
mxy<-mxy %>% arrange(Animal,Track,Step,jStep)

rm(behav_chains)
```

##Spatial Prediction

### Per Animal
```{r}
sxy<-split(mxy,mxy$Animal)
spp<-lapply(sxy,function(x){
  pp<-bbox(cbind(x$x,x$y))
  m <- get_map(location=pp,zoom=4,source="google",scale=2,maptype="satellite")
  ggmap(m)+geom_path(data=x, aes(x=x, y=y,col=phi),size=.5)   + scale_color_continuous(low='blue',high='red',limits=c(0,1)) + labs(col="Probability of Feeding") + facet_wrap(~Animal) + theme_bw()
})
spp

```


### Per Track
```{r,fig.height=10,fig.width=12}
sxy<-split(mxy,list(mxy$Animal),drop=T)
spp<-lapply(sxy,function(x){
  pp<-bbox(cbind(x$x,x$y))
  m <- get_map(location=pp,source="google",zoom=5,scale=2,maptype="satellite")
  ggmap(m)+geom_path(data=x, aes(x=x, y=y,col=phi),size=.5)   + scale_color_continuous(limits=c(0,1),low='blue',high='red') + labs(col="Probability of Feeding") + facet_wrap(~Track) + theme_bw()
})
spp
```

##Log Odds of Feeding
```{r}
#phi and ocean plot
ggplot(data=mxy,aes(x=ocean,y=logit(phi))) + geom_point() + labs(x="Ocean Depth",y="Estimated Log Odds of Feeding") + facet_wrap(~Animal)
```

##Autocorrelation in behavior

```{r}
#create proper time stamp
ggplot(data=mxy,aes(x=as.POSIXct(timestamp),y=phi,col=ocean)) + geom_line(aes(group=Animal),size=2.5) + labs("Probability of Feeding") + theme_bw() + scale_color_continuous(low='light blue',high='black') + labs(x="Time",y="Liklihood of Feeding") + facet_wrap(~Animal,ncol=2,scales="free") + ylim(0,1)
```

##Phase prediction

```{r,eval=F}
#order by time.
mxy$time<-as.POSIXct(mxy$timestamp)

mxy$State<-mxy$phi>0.5
mxy$State<-as.factor(mxy$State)
levels(mxy$State)<-c("Traveling","Feeding")  

mxy<-mxy %>% arrange(Animal,`time`)

#calculate runs
sxy<-split(mxy,mxy$Animal)

state_shade<-lapply(sxy,function(x){
  
  #run lengths
  state_change<-rle(as.numeric(x$State))
  
  #get time for each length switch
  xt<-x$time[cumsum(state_change$lengths[-length(state_change$lengths)])]
  xmax<-x$time[cumsum(state_change$lengths)]
  
  #time limits
  state_shade<-data.frame(xmin=c(0,xt),xmax=xmax,Behavior=state_change$values)
})
names(state_shade)<-1:length(state_shade)
state_shade<-melt(state_shade,c("xmin","xmax","Behavior"))
colnames(state_shade)<-c("xmin","xmax","Behavior","Animal")

state_shade$Behavior<-as.factor(state_shade$Behavior)
levels(state_shade$Behavior)<-c("Traveling","Feeding")
ggplot() + geom_rect(data=state_shade,aes(xmin=xmin,xmax=xmax,fill=Behavior), ymin=-Inf,ymax=Inf) + facet_wrap(~Animal,ncol=1) + theme_bw() + geom_line(data=mxy,aes(x=time,y=phi)) + ylim(0,1) + labs(fill="True Behavior",y="Estimated Probability of Feeding")
```

##Behavioral description

###Average time in phase

* For each draw, create a behavioral sequence, calculate the average runs for each behavior

## Predicted Run Length
```{r}
statec<-pc %>% filter(parameter=='state')

#split by animal and draw and chain
astate<-split(statec,list(statec$Animal,statec$Draw,statec$chain))

#get run length

runs<-lapply(astate,function(x){
  #arrange by step
  #calculate run length
  state_change<-rle(as.numeric(x$value))
  runl<-data.frame(Animal=unique(x$Animal),runs=state_change$lengths,Behavior=state_change$values)
  runl$Behavior<-as.factor(runl$Behavior)
  levels(runl$Behavior)<-c("Traveling","Feeding")
  
  return(runl)
})

runs<-rbind_all(runs)

#turn steps to hours
runs$hours<-runs$runs*step_length
ggplot(runs,aes(x=as.numeric(hours),fill=Behavior)) + geom_histogram(position='dodge') + scale_x_continuous(breaks=seq(0,max(runs$hours),by=48)) + labs(x="Hours") + ggtitle("Predicted Behavior Duration") + theme_bw()
```

```{r,fig.height=3,fig.with=3.5}
mr<-runs %>% group_by(Behavior) %>% summarize(mean=mean(hours),lower=quantile(runs,0.05),upper=quantile(runs,0.95))
ggplot(mr,aes(x=Behavior,y=mean,ymin=lower,ymax=upper)) + geom_pointrange(size=2) + theme_bw() + ggtitle("Average Duration of Behavior") + labs(y="Hours")
```

###Proportional Hazards

TODO: NEEDS TO ACCOUNT FOR CENSORED DATA! 

Survival analysis typically examines the relationship between time to death as a function of covariates. From this we can get the instantaneous rate of death at time t f(t), which is the cumulative distribution of the likelihood of death.

Let T represent survival time.

$$ P(t) = Pr(T<t)$$ 
with a pdf
$$p(t) = \frac{dP(t)}{dt}$$

The instantaneous risk of death at time t (h(t)), conditional on survival to that time:

$$ h(t) = \lim{\Delta_t\to 0} \frac{Pr[(t<T<t + \Delta_t)]|T>t}{\Delta t}$$

with covariates:
$$log (h_i(t)) = \alpha + \beta_i *x$$

The cox model has no intercept, making it semi-parametric
$$ log(h_i(t)) = h_0(t) + \beta_1 * x$$

```{r}
#Create a 'bout' encoding for every time it changes
statec[cumsum(runs$hours),"Bout"]<-seq(1,nrow(runs),1)

#Fill missing NA values
repeat.before = function(x) {   # repeats the last non NA value. Keeps leading NA
    ind = which(!is.na(x))      # get positions of nonmissing values
    if(is.na(x[1]))             # if it begins with a missing, add the 
          ind = c(1,ind)        # first position to the indices
    rep(x[ind], times = diff(   # repeat the values at these indices
       c(ind, length(x) + 1) )) # diffing the indices + length yields how often 
}                               

statec$Bout<-repeat.before(statec$Bout)

feedr<-runs[runs$Behavior %in% "Feeding",]

#Every run eventually ends in a switch (that's what makes it a run)
feedr$status<-1

#survival analysis
tf<-coxph(Surv(time=feedr$hours,event=feedr$status)~feedr$Animal)
summary(tf)
plot(survfit(tf),ylab="Proportion still feeding",xlab="Duration (hours)")
```

```{r}
#notify end of run
save.image("SingleSpecies.RData")
```
