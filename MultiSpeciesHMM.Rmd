---
title: "Antarctic Whale Project: MultiSpecies Simulation"
author: "Ben Weinstein"
date: "May 5th, 2016"
output: 
  html_document:
    keep_md: true
    number_sections: true
    toc: true
    theme: spacelab
---

```{r,warning=FALSE,message=FALSE,echo=FALSE}
library(knitr)
opts_chunk$set(echo=F,warning=F,message=F,fig.width = 10,fig.height = 5)
library(boot)
library(raster)
library(reshape2)
library(ggplot2)
library(MASS)
library(dplyr)
library(chron)
library(gridExtra)
library(stringr)
library(R2jags)

#New model to be run, flag turned off if just updating.
newModel<-TRUE

#Source Mountains function, thanks to Sam Urmy http://www.oceanographerschoice.com/2010/10/fractal-landscapes-in-r-part-two/
source("Mountains.R")
```

```{r,eval=F}
#Load in data
load("MultiSpecies.RData")
jags$recompile()
newModel<-F
```

#Abstract
I simulated correlated random walks with similar properties to previous marine pinnepid studies. The virtue of the simulation is that we can build complexity slowly. At each step we can verify that the model captures the true, known, relationship. Once we have developed a model that satisfies our aims, we can then apply it to the observed data.

## To add
* Hierarchical variance among individuals
* Observation Error
* Posterior Model Checks

#Correlated random walk

*Process Model*

$$ d_{t} \sim T*d_{t-1} + Normal(0,\Sigma)$$
$$ x_t = x_{t-1} + d_{t} $$

## Parameters

For each individual:

$$\theta = \text{Mean turning angle}$$
$$\gamma = \text{Move persistence} $$

For both behaviors process variance is:
$$ \sigma_{latitude} = 0.1$$
$$ \sigma_{longitude} = 0.1$$

###Behavioral States

$$ Behavior_1 = \text{traveling}$$
$$ Behavior_2 = \text{foraging}$$

$$ \alpha_{1,1} = \text{Probability of remaining traveling when traveling}$$
$$\alpha_{2,1} = \text{Probability of switching from feeding to traveling}$$

$$\begin{matrix}
  \alpha_{1,1} & 1-\alpha_{1,1} \\
  \alpha_{2,1} & 1-\alpha_{2,1} \\
\end{matrix}
$$

###Environment

Behavioral states are a function of local environmental conditions. The first environmental condition is ocean depth. I then build a function for preferential foraging in shallow waters.

It generally follows the form, conditional on behavior at t -1:

$$Behavior_t \sim Multinomial([\phi_{traveling},\phi_{foraging}])$$
$$logit(\phi_{traveling}) = \alpha_{Behavior_{t-1}} + \beta_1 * Ocean_{y[t,]}$$
$$logit(\phi_{foraging}) = \alpha_{Behavior_{t-1}} + \beta_2 * Ocean_{y[t,]}$$


```{r}
traj<-function(gamma=gamma,theta=theta,a1=a1,habitat=habitat,beta=beta,steps=steps){
  
  #Position Vector
  xy<-matrix(nrow=steps,ncol=2)

  #Displacement Vector
  d<-matrix(nrow=steps,ncol=2)
  
  #Behavioral States (at time t)
  state<-c()
  
  #Environment
  ocean<-c()
  
  #Effect of env
  beta<-beta
  
  #Probability of staying in behavior
  alpha<-matrix(nrow=1,ncol=2)
  phi<-matrix(nrow=steps,ncol=2)

  #Mean turning angle
  theta=theta
  
  #Degree of autocorrelation
  gamma=gamma
  
  #Process variance in latitude
  sigma_lat=0.2
  
  #Process variance in longitude
  sigma_lon=0.2
  
  #Correlation in process variance
  rho=0
  
  #Multivariate Normal Variance in random walk
  Sigma<-matrix(nrow=2,ncol=2)
  Sigma[1,1] <- sigma_lon^2
  Sigma[1,2] <- rho * sigma_lon * sigma_lat
  Sigma[2,1] <- rho * sigma_lon * sigma_lat
  Sigma[2,2] <- sigma_lat^2
  
  #Transition matrix for correlated movement
  T<-array(dim=c(steps,2,2))
  
####Process Model
  
  ##Initial position##
  xy[1,]<-mvrnorm(mu=c(0,0),Sigma=Sigma)
  
  #First env
  ocean[1]<-extract(habitat,SpatialPoints(data.frame(t(xy[1,]))))
  
  #First behavioral state is a random draw from two probabilities
  lambda<-c()
  lambda[1]<-0.5
  lambda[2]<-1-lambda[1]
  state[1] <- sample(c(1,2),size=1,prob=lambda)
  
  #First step is random walk
  xy[2,]<-mvrnorm(mu=xy[1,],Sigma = Sigma)

  #Draw random walk locations
  for (x in 2:(steps-1)){
    
    #Extract env
    ocean[x]<-extract(habitat,SpatialPoints(data.frame(t(xy[x,]))))
    
    #Behavior
    phi[x,1] <- inv.logit(a1[state[x-1]]+beta[state[x-1]]*ocean[x])
    phi[x,2]<- 1 - phi[x,1]
    state[x] <- sample(c(1,2),size=1,prob=phi[x,])
    
    #Movement correlation matrix
    T[x,1,1] <- cos(theta[state[x]])
    T[x,1,2] <- -sin(theta[state[x]])
    T[x,2,1] <- sin(theta[state[x]])
    T[x,2,2] <- cos(theta[state[x]])
    
    # Add Correlated Displacement
    d[x,]<-xy[x,] + gamma[state[x]] * T[x,,] %*% (xy[x,]  - xy[x-1,])
    
    #next position
    ## Random walk
    xy[x+1,]<-mvrnorm(n=1,mu=d[x,],Sigma=Sigma)
  }
  
  #Format to data frame
  dxy<-data.frame(xy)
  colnames(dxy)<-c("x","y")
  dxy$Step<-1:nrow(dxy)
  
  #Behavior
  dxy$State<-as.factor(c(state,NA))
  
  #Ocean
  #grab last point
  ocean[steps]<-extract(habitat,SpatialPoints(data.frame(t(xy[steps,]))))

  dxy$ocean<-ocean
  levels(dxy$State)<-c("Traveling","Feeding")
  return(dxy)
}
```

#Simulation

Values come from Jonsen (2005) and Jonsen (2016) fit for foraging seals.

##Behavioral States
### Traveling
$$\gamma_1 = 0.9 = \text{Strong Movement Persistence}$$
$$\theta_1 = 0 = \text{No preference in turns}$$

### Foraging
$$\gamma_2 = 0.1 = \text{Weak Movement Persistence}$$
$$\theta_2 = pi = \text{Many reversals in turns}$$

Essentially, whales travel long straight distances to find food sources, but then stay in those patches for a long time. 

### Environment
Whales tend to travel in deep habitats, slighlty weaker effect of ocean depth
$$\alpha = -2$$
$$\beta_1=1$$

$$\alpha = -2$$
$$\beta_1=1$$
The intercept alpha determines the crossing point, i.e the depth at which a foraging whale is likely to begin foraging. Here is set to be around 200m water following 
[dive profile based on Stimpert (2012).](http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0051214)

This is easiest to understand graphically.

```{r,fig.height=3,fig.width=3.5}
dplot<-function(a1,beta,x){
  y<-inv.logit(a1[1]+beta[1]*x)
  d11<-data.frame(x,y,State="Traveling",Begin="Traveling")
  
  y<-1-inv.logit(a1[1]+beta[1]*x)
  d12<-data.frame(x,y,State="Feeding",Begin="Traveling")

  y<-inv.logit(a1[2]+beta[2]*x)
  d21<-data.frame(x,y,State="Traveling",Begin="Feeding")
  
  y<-1-inv.logit(a1[2]+beta[2]*x)
  d22<-data.frame(x,y,State="Feeding",Begin="Feeding")
  
  d<-rbind_all(list(d11,d12,d21,d22))
}
```

```{r}
#Simulate Data
#Move persistance
gamma=c(0.9,0.1)

#Turning angle
theta=c(0,pi)

#Transitions
a1=c(-2,-2)

#Effect of ocean depth
beta=c(1,1)

#Simulate environment
#Create environment
#m<-raster(mountains(7,0.2))
#r<-(m-max(m[]))*-3
#ras2<-raster(xmn=-100,xmx=100,ymn=-100,ymx=100,resolution=0.25,crs=NA)
#r2<-setExtent(r,ras2)
#habitat<-resample(r2,ras2)

if(newModel){
  habitat<-raster(xmn=-100,xmx=100,ymn=-100,ymx=100,resolution=0.25,crs=NA,vals=runif(640000,0,6))
}

#Visualize
d<-dplot(x=seq(min(habitat[]),max(habitat[]),0.1),a1=a1,beta=beta)

ggplot(d,aes(x=x,y=y,col=State)) + geom_line() + geom_point() +  labs(x="Ocean Depth (km)",y="Probability of State") + theme_bw() + facet_wrap(~Begin)

cr<-colorRampPalette(c("white","black"))
dev.off()
plot(habitat,main='Ocean Depth (km)',col=cr(10))
```

### Multiple trajectories.
```{r}
mxy<-list()

#how many steps for each individual
step.ind<-c(200,100,150,175)

if(newModel){
    for(x in 1:4){
      mxy[[x]]<-traj(gamma=gamma,theta=theta,a1=a1,habitat=habitat,beta=beta,steps=step.ind[x])
  } 
  mxy<-melt(mxy,id.vars=c("x","y","Step","State","ocean"))
  #Label Individual
  colnames(mxy)[colnames(mxy) %in% 'L1']<-"Animal"

}

#bounding box
bb<-bbox(cbind(mxy$x,mxy$y))

#Habitat dataframe for modeling
crop_habitat<-crop(habitat,bb*2)
habitatdf<-as.data.frame(crop_habitat,xy=TRUE)

ggplot(mxy,aes(x=x,y=y)) + theme_bw() + coord_cartesian(xlim=bb[1,],ylim=bb[2,]) +  geom_raster(data=habitatdf,aes(x=x,y=y,fill=layer)) + scale_fill_continuous("Ocean Depth",low='grey90',high='black')    + geom_path(aes(col=State,group=Animal),size=1) + facet_wrap(~Animal,scales='free')

ggplot(mxy,aes(x=ocean,y=as.numeric(State)-1)) + geom_point() + stat_smooth(method="glm",method.args = list(family="binomial"),alpha=0.1) + scale_y_continuous(breaks=c(0,0.5,1),labels=c("Traveling","0.5","Feeding")) + ylab("Probability") + xlab("Ocean Depth") + theme_bw() + stat_bin_2d() + scale_fill_continuous(low='blue',high='red')
```

#Model Fitting

The goal of the model is to capture the true parameter we simulated above. As we increase complexity, we will be able to monitor the validity of our approach.

```{r,eval=T}
#source model
source("Bayesian/MultiSpecies.R")

#print model
print.noquote(readLines("Bayesian/MultiSpecies.R"))

#prior shape
R <- diag(c(1,1))

#steps for each individual
steps<-as.numeric(table(mxy$Animal))

#make ocean a matrix
oc<-acast(mxy,Animal~Step,value.var="ocean")

#Individuals
ind=max(mxy$Animal)

#obs array
obs<-melt(mxy,measure.vars=c("x","y"))
obs<-acast(obs,Animal~Step~variable)

data=list(y=obs,steps=steps,R=R,ocean=oc,ind=ind)

#paramters to track
pt<-c("theta","gamma","alpha","beta","phi")

if(newModel){
  jagM<-jags.parallel(model.file = "Bayesian/Multi_RW.jags",data=data,n.chains=2,parameters.to.save=pt,n.iter=100,n.burnin=80,n.thin=1,DIC=FALSE)
}

```

##Chains
```{r,fig.height=10}
#bind chains
pc<-melt(jagM$BUGSoutput$sims.array)
colnames(pc)<-c("Draw","chain","par","value")

#extract parameter name
pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]

#Extract index
splitpc<-split(pc,pc$parameter)

#single index
splitpc[c("alpha","beta","gamma","theta")]<-lapply(splitpc[c("alpha","beta","gamma","theta")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Behavior=sv)
    return(pc)
})

#Double index
#none

#Triple Index 
splitpc[c("phi")]<-lapply(splitpc[c("phi")],function(x){
#As matrices
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+)]"))[,3:5]
    colnames(sv)<-c("Animal","step","Behavior")
    pc<-data.frame(x,sv)
})

#bind all matrices back together
pc<-rbind_all(splitpc)
rm(splitpc)

#plot all but d
ggplot(pc[!pc$parameter %in% c("phi"),],aes(x=Draw,y=value)) + facet_wrap(~par,scales="free",ncol=2) + geom_line(aes(col=as.factor(chain))) + labs(col="Chain")
```

```{r}
#true values
tv<-melt(list('alpha[1]'=inv.logit(a1[1]),'alpha[2]'=inv.logit(a1[2]),'theta[2]'=theta[2],'theta[1]'=theta[1],'gamma[1]'=gamma[1],'gamma[2]'=gamma[2],'beta[1]'=inv.logit(beta[1]),'beta[2]'=inv.logit(beta[2])))
colnames(tv)<-c("value","par")

#Plot
ggplot(data=pc[!pc$parameter %in% c("phi"),],aes(x=value)) + geom_histogram() + facet_wrap(~par,scales='free',ncol=4) + theme_bw() + geom_vline(data=tv,aes(xintercept=value),col='red',linetype='dashed') + ggtitle("Estimated parameters, true values in red")
```

###Compare to priors

```{r}
#add comparison to priors
todraw<-table(pc$par)[1]
pc$Estimate<-"Posterior"

#add priors
#alpha
a1prior<-data.frame(Draw=1:todraw,par='alpha[1]',value=inv.logit(rnorm(todraw,0,1.6)),parameter='alpha',Behavior=1,Estimate="Prior")

a2prior<-data.frame(Draw=1:todraw,par='alpha[2]',value=inv.logit(rnorm(todraw,0,1.6)),parameter='alpha',Behavior=2,Estimate="Prior")

beta1prior<-data.frame(Draw=1:todraw,par='beta[1]',value=inv.logit(rnorm(todraw,0,1.6)),parameter='beta',Behavior=1,Estimate="Prior")

beta2prior<-data.frame(Draw=1:todraw,par='beta[2]',value=inv.logit(rnorm(todraw,0,1.6)),parameter='beta',Behavior=2,Estimate="Prior")

gamma1prior<-data.frame(Draw=1:todraw,par='gamma[1]',value=rbeta(todraw,5,2),parameter='gamma',Behavior=1,Estimate="Prior")

gamma2prior<-data.frame(Draw=1:todraw,par='gamma[2]',value=rbeta(todraw,2,5),parameter='gamma',Behavior=2,Estimate="Prior")

prs<-rbind_all(list(a1prior,a2prior,beta1prior,beta2prior,gamma1prior,gamma2prior))

prs$Behavior<-as.factor(prs$Behavior)

allp<-rbind_all(list(pc[!pc$parameter %in% c("phi"),],prs))

ggplot(allp,aes(x=Behavior,y=value,fill=Estimate)) + geom_violin() + facet_wrap(~parameter,scale="free")
```

##Prediction - environmental function

```{r}
alphap<-cbind(pc %>% filter(par=='alpha[1]') %>% .$value,pc %>% filter(par=='alpha[2]') %>% .$value)

betap<-cbind(pc %>% filter(par=='beta[1]') %>% .$value,pc %>% filter(par=='beta[2]') %>% .$value)
 
postplot<-list()

for(j in 1:nrow(alphap)){
  postplot[[j]]<-data.frame(dplot(x=mxy$ocean,a1=logit(alphap[j,]),beta=logit(betap[j,])),Iteration=j)
  }

postplot<-rbind_all(postplot)

dsum<-postplot %>% group_by(x,Begin,State) %>% summarize(y_mean=mean(y),lower=quantile(y,0.05),upper=quantile(y,0.95))

#overlay true value
trued<-dplot(x=seq(min(habitat[]),max(habitat[]),0.1),a1=a1,beta=beta)

ggplot(dsum[,]) + geom_ribbon(aes(x=x,y=y_mean,ymin=upper,ymax=lower,fill=State),alpha=0.5) + theme_bw() + labs(col="Transition",x="Ocean Depth (km)",y="Probability",fill="Transition") + facet_wrap(~Begin) + geom_line(data=trued,aes(x=x,y=y,col=State),linetype='dashed')

#overla
```

#Behavioral Prediction

```{r}
#We just need Feeding behavior
behav_chains<-pc[pc$Behavior == 2 & pc$parameter %in% "phi",]

#arrange by step - capitalize
behav_chains$Step<-as.numeric(as.character(behav_chains$step))
behav_chains<-behav_chains %>% arrange(Step)

#Label Behaviors
behav_chains$Behavior<-as.factor(behav_chains$Behavior)
levels(behav_chains$Behavior)<-c("Traveling","Feeding")

#average phi
mean_phi<-behav_chains %>% group_by(Animal,Step) %>% summarize(phi=mean(value))
  
#merge with input
sxy<-split(mxy,mxy$Animal)
sxy<-lapply(sxy,function(x){
  x$Step<-1:nrow(x)
  return(x)
})
mxy<-rbind_all(sxy)

mxy<-merge(mxy,mean_phi,by=c("Step","Animal"))

ggplot(data=mxy,aes(x=x, y=y,col=phi))+geom_path(size=1.5) + scale_color_continuous(low='blue',high='red') + labs(col="Probability of Feeding") + facet_wrap(~Animal,scales="free")

#phi and ocean plot
ggplot(data=mxy,aes(x=ocean,y=logit(phi))) + geom_point() + labs(x="Ocean Depth",y="Estimated Log Odds of Feeding")
```

##Autocorrelation in behavior

```{r}
ggplot(data=mxy,aes(x=as.numeric(Step),y=phi,col=ocean)) + geom_line(aes(group=Animal),size=2.5) + labs("Probability of Feeding") + theme_bw() + scale_color_continuous(low='light blue',high='black') + labs(x="Time Step",y="Liklihood of Feeding")
```

```{r}
save.image("MultiSpecies.RData")
```
