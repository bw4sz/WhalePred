---
title: "Hidden Markov Model"
author: "Ben Weinstein"
date: "May 5, 2016"
output: html_document
---

```{r,warning=FALSE,message=FALSE,echo=FALSE}
library(knitr)
opts_chunk$set(echo=F,warning=F,message=F,fig.width = 10,fig.height = 5)
library(sp)
library(dismo)
library(potools)
library(raster)
library(reshape2)
library(ggplot2)
library(MASS)
library(dplyr)
library(chron)
library(moveHMM)
library(move)
library(ggmap)
library(maps)
library(gridExtra)
library(stringr)
library(rjags)
```

#Simulation

Let's play around with a reasonable small simulations to understand what is happenning in the model. Just a random walk path with two states.

The simulation depends on X known states

$$ Distance =  \sim N(\)$$
$$ Turning Angle = \gamma \sim $$

I will then expand to include

* Multiple behavioral states, each with theiir own distances and turning angles
* Environmental features that predict behavioral states.
* Variance among individuals
* Observation Error

```{r}

  #Total number of steps
  steps=100

  #Position Vector
  xy<-matrix(nrow=steps,ncol=2)

  #Initial position
  xy[1,]<-c(0,0)
  
  #Multivariate Normal Variance in random walk
  iSigma<-matrix(nrow=2,ncol=2)
  iSigma[1,1] <- 1
  iSigma[1,2] <- 0
  iSigma[2,1] <- 0
  iSigma[2,2] <- 1
  
  ####Process Model
  ## Random walk to estimate subsequent positions
  rw<-function(x,iSigma){
    mvrnorm(n=1,mu=x,Sigma=iSigma)
  }
  
  #Draw random locations
  for (x in 2:steps){
    xy[x,]<-rw(xy[x-1,],iSigma)
  }
```

#Plot Trajectory

```{r}

dxy<-data.frame(xy)
colnames(dxy)<-c("x","y")
dxy$Step<-1:nrow(dxy)

ggplot(dxy,aes(x=x,y=y)) + geom_point(size=5,col='black') + geom_path(aes(col=Step),size=2) + scale_color_continuous(low='blue',high='red') + theme_bw()
```

#Model Fitting

The goal of the model is to capture the true parameter we simulated above. As we increase complexity, we will be able to monitor the validity of our approach.

```{r,eval=T}
#source model
source("Bayesian/RW.R")

#print model
print.noquote(readLines("Bayesian/RW.R"))
#prior shape
R <- diag(c(1,2))
data=list(y=xy,steps=nrow(xy),R=R)
yn<-matrix(nrow=nrow(xy),ncol=ncol(xy),data=1)

jags<-jags.model(file = "Bayesian/RW.jags",data=data,n.chains=2,n.adapt=1000 )
update(jags,10000)
p<-coda.samples(model=jags,n.iter=1000,n.thin=1,variable.names=c("R","iSigma"))
```

##Chains
```{r}
potrace(p)
```

##Posteriors

```{r}
#true values
tv<-melt(list(R=R,iSigma=iSigma))
tv$par<-paste(tv$L1,"[",tv$Var1,",",tv$Var2,"]",sep="")
out<-rbind(p[[1]],p[[2]])
pc<-melt(out)
colnames(pc)<-c("Draw","par","value")
ggplot(data=pc,aes(x=value)) + geom_histogram() + facet_wrap(~par,scales='free',ncol=4) + theme_bw() + geom_vline(data=tv,aes(xintercept=value),col='red',linetype='dashed') + ggtitle("Estimated parameters, true values in red")
```

##Prediction
```{r}
pr<-coda.samples(model=jags,n.iter=100,n.thin=1,variable.names=c("ynew"))
ps<-posummary(pr)
ps<-melt(ps)

#extract positions
sv<-data.frame(str_match(ps$Var1,"(\\w+)\\[(\\d+),(\\d+)]"))[,-1]
colnames(sv)<-c("par","step","xy")

#format to combine
ps<-data.frame(ps,sv)
#relevel
levels(ps$xy)<-c("x","y")
levels(ps$Var2)<-c("mean","lower","median","upper","Rhat")

#Just keep mean, upper and lower
toplot<-dcast(ps,step~xy+Var2,value.var = "value")

#arrange by step
toplot<-toplot %>% arrange(step)

ggplot(toplot,aes(x=x_mean,y=y_mean)) + geom_ribbon(alpha=0.5,aes(xmin=x_lower,xmax=x_upper,ymin=y_lower,ymax=y_upper)) + geom_path() + theme_bw() + geom_path(data=dxy,aes(x=x,y=y),col='red') + ggtitle("Predicted path (black) compared to true path (red)")
```
