---
title: "Hidden Markov Model"
author: "Ben Weinstein"
date: "May 5, 2016"
output: html_document
---

```{r,warning=FALSE,message=FALSE,echo=FALSE}
library(knitr)
opts_chunk$set(echo=F,warning=F,message=F,fig.width = 10,fig.height = 5)
library(sp)
library(dismo)
library(potools)
library(raster)
library(reshape2)
library(ggplot2)
library(MASS)
library(dplyr)
library(chron)
library(moveHMM)
library(move)
library(ggmap)
library(maps)
library(gridExtra)
library(stringr)
library(rjags)

#New model to be run, flag turned off if just updating.
newModel<-T
```

```{r,eval=F}
#Load in data
load("HMM.RData")
jags$recompile()
newModel<-F
```

#Abstract
I simulated correlated random walks with similar properties to previous marine pinnepid studies. The virtue of the simulation is that we can build complexity slowly. At each step we can verify that the model captures the true, known, relationship. Once we have developed a model that satisfies our aims, we can then apply it to the observed data.

#Correlated random walk

*Process Model*

$$ d_{t} \sim T*d_{t-1} + Normal(0,\Sigma)$$
$$ x_t = x_{t-1} + d_{t} $$

## Parameters

$$\theta = \text{Mean turning angle}$$
$$\gamma = \text{Move persistence} $$


###Behavioral States
$$ 1 = \text{foraging}$$
$$ 2 = \text{traveling}$$

I will then increase complexity to include:

* Environmental features that predict behavioral states.
* Hierarchical variance among individuals
* Observation Error

```{r}
traj<-function(gamma,theta,a1,rho=0){
  
  #Total number of steps
  steps=200

  #Position Vector
  xy<-matrix(nrow=steps,ncol=2)

  #Displacement Vector
  d<-matrix(nrow=steps,ncol=2)
  
  #Behavioral States (at time t)
  state<-c()
  
  #Probability of staying in behavior
  alpha<-matrix(nrow=1,ncol=2)
  phi<-matrix(nrow=steps,ncol=2)
  
  alpha[1]<-a1[1]
  alpha[2]<-a1[2]

  #Mean turning angle
  theta=theta
  
  #Degree of autocorrelation
  gamma=gamma
  
  #Process variance in latitude
  sigma_lat=0.2
  
  #Process variance in longitude
  sigma_lon=0.2
  
  #Correlation in process variance
  rho=rho
  
  #Multivariate Normal Variance in random walk
  Sigma<-matrix(nrow=2,ncol=2)
  Sigma[1,1] <- sigma_lon^2
  Sigma[1,2] <- rho * sigma_lon * sigma_lat
  Sigma[2,1] <- rho * sigma_lon * sigma_lat
  Sigma[2,2] <- sigma_lat^2
  
  #Transition matrix for correlated movement
  T<-array(dim=c(steps,2,2))
  
  ####Process Model
  
  #Initial position
  xy[1,]<-c(0,0)
  
  #First behavioral state is a random draw from two probabilities
  lambda<-c()
  lambda[1]<-0.5
  lambda[2]<-1-lambda[1]
  state[1] <- sample(c(1,2),size=1,prob=lambda)
  
  #First step is random walk
  xy[2,]<-mvrnorm(mu=xy[1,],Sigma = Sigma)

  #Draw random walk locations
  for (x in 2:(steps-1)){
    
    #Behavior
    phi[x,1] <- alpha[state[x-1]]
    phi[x,2] <- 1 - alpha[state[x-1]]
    state[x] <- sample(c(1,2),size=1,prob=phi[x,])
    
    #Movement correlation matrix
    T[x,1,1] <- cos(theta[state[x]])
    T[x,1,2] <- -sin(theta[state[x]])
    T[x,2,1] <- sin(theta[state[x]])
    T[x,2,2] <- cos(theta[state[x]])
    
    # Add Correlated Displacement
    d[x,]<-xy[x,] + gamma[state[x]] * T[x,,] %*% (xy[x,]  - xy[x-1,])
    
    #next position
    ## Random walk
    xy[x+1,]<-mvrnorm(n=1,mu=d[x,],Sigma=Sigma)
  }
  
  #Format to data frame
  dxy<-data.frame(xy)
  colnames(dxy)<-c("x","y")
  dxy$Step<-1:nrow(dxy)
  return(dxy)
}
```

#Simulation

##Behavioral States
$$ \alpha_{1,1} = \text{Probability of remaining feeding when feeding)} = 0.9$$
$$\alpha_{2,1} = \text{Probability of switching from traveling to feeding} = 0.2$$

From these probabilities we can compute the full transition matrix.

$$\begin{matrix}
  \alpha_{1,1} & 1-\alpha_{1,1} \\
  \alpha_{2,1} & 1-\alpha_{2,1} \\
\end{matrix}
$$

## Foraging
$$\gamma_1 = 0.1 = \text{Weak Movement Persistence}$$
$$\theta_1 = pi = \text{Many reversals in turns}$$

## Traveling
$$\gamma_2 = 0.95 = \text{Strong Movement Persistence}$$
$$\theta_2 = 0 = \text{No preference in turns}$$

For both behaviors process variance is:
$$ \sigma_{latitude} = 0.1$$
$$ \sigma_{longitude} = 0.1$$

Values come from Jonsen (2005) and Jonsen (2016) fit for foraging seals.

```{r}
gamma=c(0.95,0.1)
theta=c(0,pi)
a1=c(0.9,0.2)

if(newModel){
  dxy<-traj(gamma=gamma,theta=theta,a1=a1)  
}

ggplot(dxy,aes(x=x,y=y)) + geom_point(size=2,col='black') + geom_path(aes(col=Step),size=2) + scale_color_continuous(low='blue',high='red') + theme_bw()
```

### Multiple trajectories.
```{r}
mxy<-lapply(1:10,function(x) traj(gamma=gamma,theta=theta,a1=a1))
mxy<-melt(mxy,id.vars=c("x","y","Step"))
ggplot(mxy,aes(x=x,y=y)) + geom_path(aes(col=as.factor(L1)),size=2) + theme_bw() + scale_color_discrete(guide=F) + ggtitle("Multiple trajectories")
```

#Model Fitting

The goal of the model is to capture the true parameter we simulated above. As we increase complexity, we will be able to monitor the validity of our approach.

```{r,eval=T}
#source model
source("Bayesian/RW.R")

#print model
print.noquote(readLines("Bayesian/RW.R"))

#prior shape
R <- diag(c(1,1))
data=list(y=as.matrix(dxy[,1:2]),steps=nrow(dxy),R=R)

if(newModel){
  jags<-jags.model(file = "Bayesian/RW.jags",data=data,n.chains=2)
  }

system.time(update(jags,40000))
p<-coda.samples(model=jags,n.iter=20000,thin=20,variable.names=c("theta","gamma","alpha"))
```

##Chains
```{r,fig.height=5}
potrace(p)
```

##Posteriors

```{r}
#true values
tv<-melt(list('alpha[1]'=a1[1],'alpha[2]'=a1[2],'theta[2]'=theta[2],'theta[1]'=theta[1],'gamma[1]'=gamma[1],'gamma[2]'=gamma[2]))
colnames(tv)<-c("value","par")

#bind chains
out<-rbind(p[[1]],p[[2]])
pc<-melt(out)
colnames(pc)<-c("Draw","par","value")

#Plot
ggplot(data=pc,aes(x=value)) + geom_histogram() + facet_wrap(~par,scales='free',ncol=4) + theme_bw() + geom_vline(data=tv,aes(xintercept=value),col='red',linetype='dashed') + ggtitle("Estimated parameters, true values in red")
```

##Prediction - no error

```{r,eval=T}
pr<-coda.samples(model=jags,n.iter=1000,n.thin=5,variable.names=c("d"))
ps<-rbind(pr[[1]],pr[[2]])
ps<-melt(ps)

#extract positions
sv<-data.frame(str_match(ps$Var2,"(\\w+)\\[(\\d+),(\\d+)]"))[,-1]
colnames(sv)<-c("par","step","xy")

#format to combine
ps<-data.frame(ps,sv)
#relevel
levels(ps$xy)<-c("x","y")

#levels(ps$Var2)<-c("mean","lower","median","upper","Rhat")

#Just keep mean, upper and lower
toplot<-dcast(ps,Var1+step~xy,value.var = "value")
sumplot<-group_by(toplot,step) %>% summarize(x_mean=mean(x),y_mean=mean(y))

#arrange by step
sumplot$step<-as.numeric(as.character(sumplot$step))
sumplot<-sumplot %>% arrange(step)

ggplot(sumplot,aes(x=x_mean,y=y_mean)) + geom_path(size=2,alpha=0.5) + theme_bw() + geom_path(data=dxy,aes(x=x,y=y),col='red') + ggtitle("Predicted path (black) compared to true path (red)") 

#+ geom_path(aes(x=x_lower,y=y_lower),linetype='dashed') + #geom_path(aes(x=x_upper,y=y_upper),linetype='dashed')
```

Point Density

```{r,eval=F}
out<-rbind(pr[[1]],pr[[2]])
pc<-melt(out)
colnames(pc)<-c("Draw","param","value")

sv<-data.frame(str_match(pc$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,-1]
colnames(sv)<-c("par","step","xy")

#format to combine
pc<-data.frame(pc,sv)
#relevel
levels(pc$xy)<-c("x","y")
toplot<-dcast(pc,Draw+step~xy,value.var = "value")

#arrange by step
toplot$step<-as.numeric(as.character(toplot$step))
toplot<-toplot %>% arrange(step)

ggplot(data=toplot,aes(x=x,y=y,col=step)) + geom_point() + theme_bw()
```

```{r}
save.image("HMM.RData")
```
