---
title: "Antarctic Whale Project: Simulation"
author: "Ben Weinstein"
date: "May 5th, 2016"
output: 
  html_document:
    keep_md: True
    numbered_sections: True
    toc: true
    theme: spacelab
---

```{r,warning=FALSE,message=FALSE,echo=FALSE}
library(knitr)
opts_chunk$set(echo=F,warning=F,message=F,fig.width = 10,fig.height = 5)
library(boot)
library(potools)
library(raster)
library(reshape2)
library(ggplot2)
library(MASS)
library(dplyr)
library(chron)
library(gridExtra)
library(stringr)
library(rjags)

#New model to be run, flag turned off if just updating.
newModel<-FALSE

#Source Mountains function, thanks to Sam Urmy http://www.oceanographerschoice.com/2010/10/fractal-landscapes-in-r-part-two/
source("Mountains.R")
```

```{r,eval=T}
#Load in data
load("HMM.RData")
jags$recompile()
newModel<-F
```

#Abstract
I simulated correlated random walks with similar properties to previous marine pinnepid studies. The virtue of the simulation is that we can build complexity slowly. At each step we can verify that the model captures the true, known, relationship. Once we have developed a model that satisfies our aims, we can then apply it to the observed data.

## To add
* Add coastline?
* Hierarchical variance among individuals
* Observation Error
* Posterior Model Checks

#Correlated random walk

*Process Model*

$$ d_{t} \sim T*d_{t-1} + Normal(0,\Sigma)$$
$$ x_t = x_{t-1} + d_{t} $$

## Parameters

$$\theta = \text{Mean turning angle}$$
$$\gamma = \text{Move persistence} $$

For both behaviors process variance is:
$$ \sigma_{latitude} = 0.1$$
$$ \sigma_{longitude} = 0.1$$


###Behavioral States

$$ Behavior_1 = \text{traveling}$$
$$ Behavior_2 = \text{foraging}$$

$$ \alpha_{1,1} = \text{Probability of remaining traveling when traveling}$$
$$\alpha_{2,1} = \text{Probability of switching from feeding to traveling}$$

$$\begin{matrix}
  \alpha_{1,1} & 1-\alpha_{1,1} \\
  \alpha_{2,1} & 1-\alpha_{2,1} \\
\end{matrix}
$$

###Environment

Behavioral states are a function of local environmental conditions. The first environmental condition is ocean depth. I then build a function for preferential foraging in shallow waters.

It generally follows the form, conditional on behavior at t -1:

$$Behavior_t \sim Multinomial([\phi_{traveling},\phi_{foraging}])$$
$$logit(\phi_{traveling}) = \alpha_{Behavior_{t-1}} + \beta_1 * Ocean_{y[t-1,]}$$
$$logit(\phi_{foraging}) = \alpha_{Behavior_{t-1}} + \beta_2 * Ocean_{y[t-1,]}$$


```{r}
traj<-function(gamma=gamma,theta=theta,a1=a1,habitat=habitat,beta=beta){
  
  #Total number of steps
  steps=250

  #Position Vector
  xy<-matrix(nrow=steps,ncol=2)

  #Displacement Vector
  d<-matrix(nrow=steps,ncol=2)
  
  #Behavioral States (at time t)
  state<-c()
  
  #Environment
  ocean<-c()
  
  #Effect of env
  beta<-beta
  
  #Probability of staying in behavior
  alpha<-matrix(nrow=1,ncol=2)
  phi<-matrix(nrow=steps,ncol=2)
  
  a1[1]<-a1[1]
  a1[2]<-a1[2]

  #Mean turning angle
  theta=theta
  
  #Degree of autocorrelation
  gamma=gamma
  
  #Process variance in latitude
  sigma_lat=0.2
  
  #Process variance in longitude
  sigma_lon=0.2
  
  #Correlation in process variance
  rho=0
  
  #Multivariate Normal Variance in random walk
  Sigma<-matrix(nrow=2,ncol=2)
  Sigma[1,1] <- sigma_lon^2
  Sigma[1,2] <- rho * sigma_lon * sigma_lat
  Sigma[2,1] <- rho * sigma_lon * sigma_lat
  Sigma[2,2] <- sigma_lat^2
  
  #Transition matrix for correlated movement
  T<-array(dim=c(steps,2,2))
  
####Process Model
  
  ##Initial position##
  xy[1,]<-mvrnorm(mu=c(0,0),Sigma=Sigma)
  
  #First env
  ocean[1]<-extract(habitat,SpatialPoints(data.frame(t(xy[1,]))))
  
  #First behavioral state is a random draw from two probabilities
  lambda<-c()
  lambda[1]<-0.5
  lambda[2]<-1-lambda[1]
  state[1] <- sample(c(1,2),size=1,prob=lambda)
  
  #First step is random walk
  xy[2,]<-mvrnorm(mu=xy[1,],Sigma = Sigma)

  #Draw random walk locations
  for (x in 2:(steps-1)){
    
    #Extract env
    ocean[x]<-extract(habitat,SpatialPoints(data.frame(t(xy[x,]))))
    
    #Behavior
    phi[x,1] <- inv.logit(a1[state[x-1]]+beta[state[x-1]]*ocean[x])
    phi[x,2]<- 1 - phi[x,1]
    state[x] <- sample(c(1,2),size=1,prob=phi[x,])
    
    #Movement correlation matrix
    T[x,1,1] <- cos(theta[state[x]])
    T[x,1,2] <- -sin(theta[state[x]])
    T[x,2,1] <- sin(theta[state[x]])
    T[x,2,2] <- cos(theta[state[x]])
    
    # Add Correlated Displacement
    d[x,]<-xy[x,] + gamma[state[x]] * T[x,,] %*% (xy[x,]  - xy[x-1,])
    
    #next position
    ## Random walk
    xy[x+1,]<-mvrnorm(n=1,mu=d[x,],Sigma=Sigma)
  }
  
  #Format to data frame
  dxy<-data.frame(xy)
  colnames(dxy)<-c("x","y")
  dxy$Step<-1:nrow(dxy)
  
  #Behavior
  dxy$State<-as.factor(c(state,NA))
  
  #Ocean
  #grab last point
  ocean[steps]<-extract(habitat,SpatialPoints(data.frame(t(xy[steps,]))))

  dxy$ocean<-ocean
  levels(dxy$State)<-c("Traveling","Feeding")
  return(dxy)
}
```

#Simulation

Values come from Jonsen (2005) and Jonsen (2016) fit for foraging seals.

##Behavioral States
### Traveling
$$\gamma_1 = 0.9 = \text{Strong Movement Persistence}$$
$$\theta_1 = 0 = \text{No preference in turns}$$

### Foraging
$$\gamma_2 = 0.1 = \text{Weak Movement Persistence}$$
$$\theta_2 = pi = \text{Many reversals in turns}$$

Essentially, whales travel long straight distances to find food sources, but then stay in those patches for a long time. 

### Environment
Whales tend to travel in deep habitats
$$\alpha_1 = -2$$
$$\beta_1=10$$

Whales tend to forage in shallow habitats
$$\alpha_1 = -2$$
$$\beta_2=10$$

The intercept alpha determines the crossing point, i.e the depth at which a foraging whale is likely to begin foraging. Here is set to be around 200m water following 
[dive profile based on Stimpert (2012).](http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0051214)

This is easiest to understand graphically.

```{r,fig.height=3,fig.width=3.5}
dplot<-function(a1,beta,x){
  y<-inv.logit(a1[1]+beta[1]*x)
  d11<-data.frame(x,y,State='Traveling',k='Traveling')
  
  y<-1-inv.logit((a1[1])+beta[1]*x)
  d12<-data.frame(x,y,State='Traveling',k='Feeding')
  
  y<-inv.logit(a1[2]+beta[2]*x)
  d21<-data.frame(x,y,State='Feeding',k='Traveling')
  
  y<-1-inv.logit((a1[2])+beta[2]*x)
  d22<-data.frame(x,y,State='Feeding',k='Feeding')
  
  d<-rbind_all(list(d11,d12,d21,d22))
}
```

```{r}
#Simulate Data
#Move persistance
gamma=c(0.9,0.1)

#Turning angle
theta=c(0,pi)

#Transitions
a1=c(-2,-2)

#Effect of ocean depth
beta=c(10,10)

#Simulate environment
#Create environment
m<-raster(mountains(7,1.2))
r<-(m-max(m[]))*-5/1000
ras2<-raster(xmn=-100,xmx=100,ymn=-100,ymx=100,resolution=0.25,crs=NA)
r2<-setExtent(r,ras2)
habitat<-resample(r2,ras2)

#Visualize
d<-dplot(x=seq(min(habitat[]),max(habitat[]),0.01),a1=a1,beta=beta)

ggplot(d,aes(x=x,y=y,col=k)) + geom_line() + geom_point() + facet_wrap(~State) + labs(x="Ocean Depth (km)",y="Probability of State",col="Transition") + theme_bw() 

cr<-colorRampPalette(c("white","black"))
dev.off()
plot(habitat,main='Ocean Depth (km)',col=cr(10))

#Habitat dataframe for modeling
habitatdf<-as.data.frame(habitat,xy=TRUE)

if(newModel){
  dxy<-traj(gamma=gamma,theta=theta,a1=a1,habitat=habitat,beta=beta)  
}

#habitat bbounding for visualization
bb<-bbox(cbind(dxy$x,dxy$y))

ggplot(dxy,aes(x=x,y=y)) + geom_raster(data=habitatdf,aes(x=x,y=y,fill=layer)) + geom_point(size=2,col='black') + geom_path(aes(col=State,group=1),size=1.5)  + theme_bw() + scale_fill_continuous("Ocean Depth",high='black',low='grey90') + coord_cartesian(xlim=bb[1,],ylim=bb[2,])

#Behavior plot
ggplot(dxy,aes(x=ocean,y=as.numeric(State)-1)) + geom_point() + stat_smooth(method="glm",method.args = list(family="binomial")) + scale_y_continuous(breaks=c(0,1),labels=c("Traveling","Feeding")) + ylab("Probability") + xlab("Ocean Depth")
```

### Multiple trajectories.
```{r}
mxy<-lapply(1:10,function(x) traj(gamma=gamma,theta=theta,a1=a1,habitat=habitat,beta=beta))
mxy<-melt(mxy,id.vars=c("x","y","Step","State","ocean"))

#bounding box
bb<-bbox(cbind(mxy$x,mxy$y))

ggplot(mxy,aes(x=x,y=y)) + theme_bw() + coord_cartesian(xlim=bb[1,],ylim=bb[2,]) +  geom_raster(data=habitatdf,aes(x=x,y=y,fill=layer)) + scale_fill_continuous("Ocean Depth",low='grey90',high='black')    + geom_path(aes(col=State,group=L1),size=1) 

ggplot(mxy,aes(x=ocean,y=as.numeric(State)-1)) + geom_point() + stat_smooth(method="glm",method.args = list(family="binomial"),alpha=0.1) + scale_y_continuous(breaks=c(0,0.5,1),labels=c("Traveling","0.5","Feeding")) + ylab("Probability") + xlab("Ocean Depth") + theme_bw()
```

#Model Fitting

The goal of the model is to capture the true parameter we simulated above. As we increase complexity, we will be able to monitor the validity of our approach.

```{r,eval=T}
#source model
source("Bayesian/RW.R")

#print model
print.noquote(readLines("Bayesian/RW.R"))

#prior shape
R <- diag(c(1,1))
data=list(y=cbind(dxy$x,dxy$y),steps=nrow(dxy),R=R,ocean=dxy$ocean)

if(newModel){
  jags<-jags.model(file = "Bayesian/RW.jags",data=data,n.chains=2)
}

system.time(update(jags,10000))
p<-coda.samples(model=jags,n.iter=5000,thin=10,variable.names=c("theta","gamma","alpha","beta"))
```

##Chains
```{r,fig.height=5}
plot(p)
```

##Posteriors

```{r}
#true values
tv<-melt(list('alpha[1]'=inv.logit(a1[1]),'alpha[2]'=inv.logit(a1[2]),'theta[2]'=theta[2],'theta[1]'=theta[1],'gamma[1]'=gamma[1],'gamma[2]'=gamma[2],'beta[1]'=inv.logit(beta[1]),'beta[2]'=inv.logit(beta[2])))
colnames(tv)<-c("value","par")

#As matrices
sv<-data.frame(str_match(pc$par,"(\\w+)\\[(\\d+)]"))[,-1]
colnames(sv)<-c("parname","index")

pc<-data.frame(pc,sv)

#Plot
ggplot(data=pc,aes(x=value)) + geom_histogram() + facet_wrap(~par,scales='free',ncol=4) + theme_bw() + geom_vline(data=tv,aes(xintercept=value),col='red',linetype='dashed') + ggtitle("Estimated parameters, true values in red")
```

Compare to priors

```{r}
#add comparison to priors
todraw<-table(pc$par)[1]
pc$Estimate<-"Posterior"

#add priors
#alpha
a1prior<-data.frame(Draw=1:todraw,par='alpha[1]',value=runif(todraw,-5,5),parname='alpha',index=1,Estimate="Prior")

a2prior<-data.frame(Draw=1:todraw,par='alpha[2]',value=runif(todraw,-5,5),parname='alpha',index=2,Estimate="Prior")

beta1prior<-data.frame(Draw=1:todraw,par='beta[1]',value=rnorm(todraw,0,0.0001),parname='beta',index=1,Estimate="Prior")

beta2prior<-data.frame(Draw=1:todraw,par='beta[2]',value=rnorm(todraw,0,0.0001),parname='beta',index=2,Estimate="Prior")

gamma1prior<-data.frame(Draw=1:todraw,par='gamma[1]',value=rbeta(todraw,5,2),parname='gamma',index=1,Estimate="Prior")

gamma2prior<-data.frame(Draw=1:todraw,par='gamma[2]',value=rbeta(todraw,2,5),parname='gamma',index=2,Estimate="Prior")

prs<-rbind_all(list(a1prior,a2prior,beta1prior,beta2prior,gamma1prior,gamma2prior))

prs$index<-as.factor(prs$index)

allp<-rbind_all(list(pc,prs))

ggplot(allp,aes(x=index,y=value,fill=Estimate)) + geom_violin() + facet_wrap(~parname,scale="free")
```

##Prediction - environmental function

```{r,fig.height=3,fig.width=3.5}
dplot<-function(x,a1,beta){

  y<-inv.logit(a1+beta*x)
  d11<-data.frame(x,y,State='Traveling',k='Traveling')
  
  y<-1-inv.logit((a1)+beta*x)
  d12<-data.frame(x,y,State='Traveling',k='Feeding')
  
  y<-inv.logit(a1+beta*x)
  d21<-data.frame(x,y,State='Feeding',k='Traveling')
  
  y<-1-inv.logit((a1)+beta*x)
  d22<-data.frame(x,y,State='Feeding',k='Feeding')
  
  d<-rbind_all(list(d11,d12,d21,d22))
  return(d)
  }
```

```{r}
alphap<-cbind(pc %>% filter(par=='alpha[1]') %>% .$value,pc %>% filter(par=='alpha[2]') %>% .$value)

betap<-cbind(pc %>% filter(par=='beta[1]') %>% .$value,pc %>% filter(par=='beta[2]') %>% .$value)

postplot<-list()

for(j in 1:nrow(alphap)){
  postplot[[j]]<-data.frame(dplot(x=dxy$ocean,a1=alphap[j,],beta=betap[j,]),Iteration=j)
}

postplot<-rbind_all(postplot)

dsum<-postplot %>% group_by(x,State,k) %>% summarize(y_mean=mean(y),lower=quantile(y,0.05),upper=quantile(y,0.95))

ggplot(dsum,aes(x=x,y=y_mean,ymin=upper,ymax=lower,col=k,fill=k)) + geom_ribbon() + facet_wrap(~State) + theme_bw() + labs(col="Transition",x="Ocean Depth (km)",y="Probability",fill="Transition")
```

##Prediction - spatial location

```{r,eval=T}
pr<-coda.samples(model=jags,n.iter=2000,n.thin=5,variable.names=c("d"))
ps<-rbind(pr[[1]],pr[[2]])
ps<-melt(ps)

#extract positions
sv<-data.frame(str_match(ps$Var2,"(\\w+)\\[(\\d+),(\\d+)]"))[,-1]
colnames(sv)<-c("par","step","xy")

#format to combine
ps<-data.frame(ps,sv)
#relevel
levels(ps$xy)<-c("x","y")

#Just keep mean, upper and lower
toplot<-dcast(ps,Var1+step~xy,value.var = "value")
sumplot<-group_by(toplot,step) %>% summarize(x_mean=mean(x),y_mean=mean(y))

#arrange by step
sumplot$step<-as.numeric(as.character(sumplot$step))
sumplot<-sumplot %>% arrange(step)

ggplot(sumplot,aes(x=x_mean,y=y_mean)) + geom_path(size=2,alpha=0.5) + theme_bw() + geom_path(data=dxy,aes(x=x,y=y),col='red') + ggtitle("Predicted path (black) compared to true path (red)") 
```

### Point Density

```{r,eval=T}
out<-rbind(pr[[1]],pr[[2]])
pc<-melt(out)
colnames(pc)<-c("Draw","param","value")

sv<-data.frame(str_match(pc$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,-1]
colnames(sv)<-c("par","step","xy")

#format to combine
pc<-data.frame(pc,sv)
#relevel
levels(pc$xy)<-c("x","y")
toplot<-dcast(pc,Draw+step~xy,value.var = "value")

#arrange by step
toplot$step<-as.numeric(as.character(toplot$step))
toplot<-toplot %>% arrange(step)

ggplot(data=toplot,aes(x=x,y=y,col=step)) + geom_point() + theme_bw()
```

#Behavioral Prediction

```{r}
#needs to be same number of draws as spatial above
behav<-coda.samples(model=jags,n.iter=2000,n.thin=5,variable.names=c("phi"))

#bind chains
behav_chains<-rbind(behav[[1]],behav[[2]])
behav_chains<-melt(behav_chains)
colnames(behav_chains)<-c("Draw","par","value")

#As matrices
sv<-data.frame(str_match(behav_chains$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,-1]
colnames(sv)<-c("parname","index")

#format to combine
behav_chains<-data.frame(behav_chains,sv)
colnames(behav_chains)<-c("Draw","par","Probability","parname","step","Behavior")

#We just need Feeding behavior
behav_chains<-behav_chains[behav_chains$Behavior == 2,]

#arrange by step
behav_chains$step<-as.numeric(as.character(behav_chains$step))
behav_chains<-behav_chains %>% arrange(step)

#Label Behaviors
behav_chains$Behavior<-as.factor(behav_chains$Behavior)
levels(behav_chains$Behavior)<-c("Traveling","Feeding")

#combine with spatial prediction
spp_b<-merge(toplot,behav_chains,by=c("Draw","step"))

#get mean value
mean_phi<-behav_chains %>% group_by(step) %>% summarize(phi=mean(Probability))

#merge with input
dxy<-merge(dxy,mean_phi,by.x="Step",by.y="step")

ggplot()+geom_path(data=dxy, aes(x=x, y=y,col=phi),size=2) + scale_color_continuous(low='blue',high='red') + labs(col="Probability of Feeding")
```

##Autocorrelation in behavior

```{r}
ggplot(data=dxy,aes(x=as.numeric(Step),y=phi,col=ocean)) + geom_line(aes(group=1),size=2.5) + labs("Probability of Feeding") + theme_bw() + scale_color_continuous(low='light blue',high='black') + labs(x="Time Step",y="Liklihood of Feeding")
```

```{r}
save.image("HMM.RData")
```
