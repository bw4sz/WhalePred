---
title: "Hidden Markov Model"
author: "Ben Weinstein"
date: "May 5, 2016"
output: html_document
---

```{r,warning=FALSE,message=FALSE,echo=FALSE}
library(knitr)
opts_chunk$set(echo=F,warning=F,message=F,fig.width = 10,fig.height = 5)
library(sp)
library(dismo)
library(potools)
library(raster)
library(reshape2)
library(ggplot2)
library(MASS)
library(dplyr)
library(chron)
library(moveHMM)
library(move)
library(ggmap)
library(maps)
library(gridExtra)
library(stringr)
library(rjags)
```

```{r,eval=F}
#Load in data
load("HMM.RData")
jags$recompile()
```

#Abstract
I simulated correlated random walks with similar properties to previous marine pinnepid studies. The virtue of the simulation is that we can build complexity slowly. At each step we can verify that the model captures the true, known, relationship. Once we have developed a model that satisfies our aims, we can then apply it to the observed data.

#Correlated random walk

*Process Model*

$$ d_{t} \sim T*d_{t-1} + Normal(0,\Sigma)$$
$$ x_t = x_{t-1} + d_{t} $$

## Parameters

$$\theta = \text{Mean turning angle}$$
$$\gamma = \text{Move persistence} $$
$$\rho = \text{Correlation in movement process}$$

I will then increase complexity to include:

* Multiple behavioral states, each with their own distances and turning angles
* Environmental features that predict behavioral states.
* Hierarchical variance among individuals
* Observation Error

```{r}
traj<-function(gamma,theta,rho=0){
  
  #Total number of steps
  steps=200

  #Position Vector
  xy<-matrix(nrow=steps,ncol=2)

  #Displacement Vector
  d<-matrix(nrow=steps,ncol=2)

  #Mean turning angle
  theta=theta
  
  #Degree of autocorrelation
  gamma=gamma
  
  #Process variance in latitude
  sigma_lat=0.1
  
  #Process variance in longitude
  sigma_lon=0.1
  
  #Correlation in process variance
  rho=rho
  
  #Multivariate Normal Variance in random walk
  Sigma<-matrix(nrow=2,ncol=2)
  Sigma[1,1] <- sigma_lon^2
  Sigma[1,2] <- rho * sigma_lon * sigma_lat
  Sigma[2,1] <- rho * sigma_lon * sigma_lat
  Sigma[2,2] <- sigma_lat^2
  
  #Transition matrix for correlated movement
  T<-matrix(nrow=2,ncol=2)
  T[1,1] <- cos(theta)
  T[1,2] <- -sin(theta)
  T[2,1] <- sin(theta)
  T[2,2] <- cos(theta)
  
  ####Process Model
  
  #Initial position
  xy[1,]<-c(0,0)
  
  #First step is random walk
  xy[2,]<-mvrnorm(mu=xy[1,],Sigma = Sigma)
  
  #Draw random walk locations
  for (x in 2:(steps-1)){

    # Add Correlated Displacement
    d[x,]<-xy[x,] + gamma * T %*% (xy[x,]  - xy[x-1,])
    
    #next position
    ## Random walk
    xy[x+1,]<-mvrnorm(n=1,mu=d[x,],Sigma=Sigma)
  }
  
  #Format to data frame
  dxy<-data.frame(xy)
  colnames(dxy)<-c("x","y")
  dxy$Step<-1:nrow(dxy)
  return(dxy)
}
```

#Single Trajectory

Start with reasonable defaults
$$\gamma = 1 = \text{Strong Movement Persistence}$$
$$\theta = 0 = \text{No preference in turns}$$
$$ \rho = 0 = \text{No correlation between heading northwest or southeast}$$
$$ \sigma_{latitude} = 0.1$$
$$ \sigma_{longitude} = 0.1$$

Values come from Jonsen (2005) fit for foraging seals.

```{r}
gamma=1
theta=0

dxy<-traj(gamma=gamma,theta=theta)
ggplot(dxy,aes(x=x,y=y)) + geom_point(size=2,col='black') + geom_path(aes(col=Step),size=2) + scale_color_continuous(low='blue',high='red') + theme_bw()
```

### Plot many trajectories.
```{r}
mxy<-lapply(1:10,function(x) traj(gamma=gamma,theta=theta))
mxy<-melt(mxy,id.vars=c("x","y","Step"))
ggplot(mxy,aes(x=x,y=y)) + geom_path(aes(col=as.factor(L1)),size=2) + theme_bw() + scale_color_discrete(guide=F) + ggtitle("Multiple trajectories")
```

#Model Fitting

The goal of the model is to capture the true parameter we simulated above. As we increase complexity, we will be able to monitor the validity of our approach.

```{r,eval=T}
#source model
source("Bayesian/RW.R")

#print model
print.noquote(readLines("Bayesian/RW.R"))

#prior shape
R <- diag(c(1,1))
data=list(y=as.matrix(dxy[,1:2]),steps=nrow(dxy),R=R)

jags<-jags.model(file = "Bayesian/RW.jags",data=data,n.chains=2)
system.time(update(jags,20000))
p<-coda.samples(model=jags,n.iter=5000,n.thin=2,variable.names=c("Sigma","theta","gamma"))
```

##Chains
```{r,fig.height=5}
potrace(p)
```

##Posteriors

```{r}
#true values
tv<-melt(list(theta=theta,gamma=gamma,'Sigma[1,1]'=0.025,'Sigma[1,2]'=0,'Sigma[2,1]'=0,'Sigma[2,2]'=0.025))
colnames(tv)<-c("value","par")

#bind chains
out<-rbind(p[[1]],p[[2]])
pc<-melt(out)
colnames(pc)<-c("Draw","par","value")

#Plot
ggplot(data=pc,aes(x=value)) + geom_histogram() + facet_wrap(~par,scales='free',ncol=4) + theme_bw() + geom_vline(data=tv,aes(xintercept=value),col='red',linetype='dashed') + ggtitle("Estimated parameters, true values in red")
```

##Prediction - no error

```{r,eval=T}
pr<-coda.samples(model=jags,n.iter=10000,n.thin=10,variable.names=c("d"))
ps<-rbind(pr[[1]],pr[[2]])
ps<-melt(ps)

#extract positions
sv<-data.frame(str_match(ps$Var2,"(\\w+)\\[(\\d+),(\\d+)]"))[,-1]
colnames(sv)<-c("par","step","xy")

#format to combine
ps<-data.frame(ps,sv)
#relevel
levels(ps$xy)<-c("x","y")

#levels(ps$Var2)<-c("mean","lower","median","upper","Rhat")

#Just keep mean, upper and lower
toplot<-dcast(ps,Var1+step~xy,value.var = "value")
sumplot<-group_by(toplot,step) %>% summarize(x_mean=mean(x),y_mean=mean(y))

#arrange by step
sumplot$step<-as.numeric(as.character(sumplot$step))
sumplot<-sumplot %>% arrange(step)

ggplot(sumplot,aes(x=x_mean,y=y_mean)) + geom_path(size=2,alpha=0.5) + theme_bw() + geom_path(data=dxy,aes(x=x,y=y),col='red') + ggtitle("Predicted path (black) compared to true path (red)") 

#+ geom_path(aes(x=x_lower,y=y_lower),linetype='dashed') + #geom_path(aes(x=x_upper,y=y_upper),linetype='dashed')
```

Point Density

```{r,eval=F}
out<-rbind(pr[[1]],pr[[2]])
pc<-melt(out)
colnames(pc)<-c("Draw","param","value")

sv<-data.frame(str_match(pc$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,-1]
colnames(sv)<-c("par","step","xy")

#format to combine
pc<-data.frame(pc,sv)
#relevel
levels(pc$xy)<-c("x","y")
toplot<-dcast(pc,Draw+step~xy,value.var = "value")

#arrange by step
toplot$step<-as.numeric(as.character(toplot$step))
toplot<-toplot %>% arrange(step)

ggplot(data=toplot,aes(x=x,y=y,col=step)) + geom_point() + theme_bw()
```

##Assessing Fit

```{r}
```

```{r}
save.image("HMM.RData")
```
