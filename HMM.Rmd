---
title: "Hidden Markov Model"
author: "Ben Weinstein"
date: "May 5, 2016"
output: html_document
---

```{r,warning=FALSE,message=FALSE,echo=FALSE}
library(knitr)
opts_chunk$set(echo=F,warning=F,message=F,fig.width = 10,fig.height = 5)
library(sp)
library(dismo)
library(potools)
library(raster)
library(reshape2)
library(ggplot2)
library(MASS)
library(dplyr)
library(chron)
library(moveHMM)
library(move)
library(ggmap)
library(maps)
library(gridExtra)
library(stringr)
library(rjags)
```

#Simulation

##Correlated random walk


*Process Model*

$$ d_{t} \sim T*d_{t-1} + Normal(0,\sigma)$$
$$ x+t = x_{t-1} + d_{t} $$

## Parameters

$$\theta = Mean turning angle$$
$$\gamma = Move persistance $$
$$\rho = Correlation in movement process $$

I will then expand to include

* Multiple behavioral states, each with theiir own distances and turning angles
* Environmental features that predict behavioral states.
* Hierarchical variance among individuals
* Observation Error

```{r}
traj<-function(gamma,theta,rho=0){
  #Total number of steps
  steps=100

  #Position Vector
  xy<-matrix(nrow=steps,ncol=2)

  #Displacement Vector
  d<-matrix(nrow=steps,ncol=2)
  
  #Initial position
  xy[1,]<-c(0,0)
  d[1,]<-c(0,0)
  
  #Mean turning angle
  theta=theta
  
  #Degree of autocorrelation
  gamma=gamma
  
  #Process variance in latitude
  sigma_lat=0.1
  
  #Process variance in longitude
  sigma_lon=0.1
  
  #Correlation in process variance
  rho=rho
  
  #Multivariate Normal Variance in random walk
  Sigma<-matrix(nrow=2,ncol=2)
  Sigma[1,1] <- sigma_lon^2
  Sigma[1,2] <- rho * sigma_lon * sigma_lat
  Sigma[2,1] <- rho * sigma_lon * sigma_lat
  Sigma[2,2] <- sigma_lat^2
  
  #Transition matrix for correlated movement
  T<-matrix(nrow=2,ncol=2)
  T[1,1] <- cos(theta)
  T[1,2] <- -sin(theta)
  T[2,1] <- sin(theta)
  T[2,2] <- cos(theta)
  
  ####Process Model
  ## Random walk to estimate subsequent displacements
  rw<-function(Sigma){
    mvrnorm(n=1,mu=c(0,0),Sigma=Sigma)
  }

  #Draw random walk locations
  for (x in 2:steps){
    #Displacement
    d[x,]<-gamma*T %*% d[x-1,]+rw(Sigma)

## matrix multiplication

    #next position
    xy[x,]<-xy[x-1,] + d[x,]
  }
  
  #Format to data frame
  dxy<-data.frame(xy)
  colnames(dxy)<-c("x","y")
  dxy$Step<-1:nrow(dxy)
  return(dxy)
}
```

#Single Trajectory

Start with reasonable defaults
$$\gamma = 1 = \text{Strong Movement Persistance}$$
$$\theta = 0 = \text{No preference in turns}$$
$$ \rho = 0 = \text{No correlation between heading northwest or southeast}$$
$$ \sigma_lat = 0.1$$
$$ \sigma_lon = 0.1$$

Values come from Jonsen (2005) fit for foraging seals.

```{r}
gamma=0.7
theta=0
dxy<-traj(gamma=gamma,theta=theta)
ggplot(dxy,aes(x=x,y=y)) + geom_point(size=2,col='black') + geom_path(aes(col=Step),size=2) + scale_color_continuous(low='blue',high='red') + theme_bw()
```

### Plot many trajectories.
```{r}
mxy<-lapply(1:10,function(x) traj(gamma=1,theta=0,rho=0))
mxy<-melt(mxy,id.vars=c("x","y","Step"))
ggplot(mxy,aes(x=x,y=y)) + geom_path(aes(col=as.factor(L1)),size=2) + theme_bw() + scale_color_discrete(guide=F) + ggtitle("Multiple trajectories")
```

#Model Fitting

The goal of the model is to capture the true parameter we simulated above. As we increase complexity, we will be able to monitor the validity of our approach.

```{r,eval=T}
#source model
source("Bayesian/RW.R")

#print model
print.noquote(readLines("Bayesian/RW.R"))

#prior shape
R <- diag(c(1,2))
data=list(y=dxy[,1:2],steps=nrow(dxy),R=R)

jags<-jags.model(file = "Bayesian/RW.jags",data=data,n.chains=2,n.adapt=1000 )
update(jags,20000)
p<-coda.samples(model=jags,n.iter=1000,n.thin=1,variable.names=c("theta","gamma"))
```

##Chains
```{r}
potrace(p)
```

##Posteriors

```{r}
#true values
tv<-melt(list(theta=theta,gamma=gamma))
colnames(tv)<-c("value","par")

#bind chains
out<-rbind(p[[1]],p[[2]])
pc<-melt(out)
colnames(pc)<-c("Draw","par","value")

#Plot
ggplot(data=pc,aes(x=value)) + geom_histogram() + facet_wrap(~par,scales='free',ncol=4) + theme_bw() + geom_vline(data=tv,aes(xintercept=value),col='red',linetype='dashed') + ggtitle("Estimated parameters, true values in red")
```

##Prediction
```{r,eval=F}
pr<-coda.samples(model=jags,n.iter=2000,n.thin=1,variable.names=c("ynew"))
ps<-posummary(pr)
ps<-melt(ps)

#extract positions
sv<-data.frame(str_match(ps$Var1,"(\\w+)\\[(\\d+),(\\d+)]"))[,-1]
colnames(sv)<-c("par","step","xy")

#format to combine
ps<-data.frame(ps,sv)
#relevel
levels(ps$xy)<-c("x","y")
levels(ps$Var2)<-c("mean","lower","median","upper","Rhat")

#Just keep mean, upper and lower
toplot<-dcast(ps,step~xy+Var2,value.var = "value")

#arrange by step
toplot$step<-as.numeric(as.character(toplot$step))
toplot<-toplot %>% arrange(step)

ggplot(toplot,aes(x=x_mean,y=y_mean)) + geom_path() + theme_bw() + geom_path(data=dxy,aes(x=x,y=y),col='red') + ggtitle("Predicted path (black) compared to true path (red)") + geom_path(aes(x=x_lower,y=y_lower),linetype='dashed') + geom_path(aes(x=x_upper,y=y_upper),linetype='dashed')
```

Point Density

```{r,eval=F}
out<-rbind(pr[[1]],pr[[2]])
pc<-melt(out)
colnames(pc)<-c("Draw","param","value")

sv<-data.frame(str_match(pc$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,-1]
colnames(sv)<-c("par","step","xy")

#format to combine
pc<-data.frame(pc,sv)
#relevel
levels(pc$xy)<-c("x","y")
toplot<-dcast(pc,Draw+step~xy,value.var = "value")

#arrange by step
toplot$step<-as.numeric(as.character(toplot$step))
toplot<-toplot %>% arrange(step)

ggplot(data=toplot,aes(x=x,y=y,col=step)) + geom_point() + theme_bw()
```


