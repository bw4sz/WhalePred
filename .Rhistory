$$logit(\phi_{foraging}) = \alpha_{Behavior_{t-1}} $$
Following Bestley in preferring to describe the switch into feeding, but no estimating the resumption of traveling.
The effect of the environment is temporally variable such that
$$ \beta_{Month,2} \sim ~ Normal(\beta_{\mu},\beta_\tau)$$
```{r,fig.height=3,fig.width=3.5}
dplot<-function(a1,beta=c(0,0),beta2=c(0,0),x=0,coast=0){
#Transition from traveling to traveling
y<-inv.logit(a1[1]+beta[1]*x + beta2[1]*coast)
d11<-data.frame(x,coast,y,State="Traveling",Begin="Traveling")
#transition from Traveling to Foraging
y<-1-inv.logit(a1[1]+beta[1]*x+ beta2[1]*coast)
d12<-data.frame(x,coast,y,State="Foraging",Begin="Traveling")
y<-inv.logit(a1[2]+beta[2]*x+ beta2[2]*coast)
d21<-data.frame(x,coast,y,State="Traveling",Begin="Foraging")
y<-1-inv.logit(a1[2]+beta[2]*x+ beta2[2]*coast)
d22<-data.frame(x,coast,y,State="Foraging",Begin="Foraging")
d<-rbind_all(list(d11,d12,d21,d22))
return(d)
}
```
##Continious tracks
The transmitter will often go dark for 10 to 12 hours, due to weather, right in the middle of an otherwise good track. The model requires regular intervals to estimate the turning angles and temporal autocorrelation. As a track hits one of these walls, call it the end of a track, and begin a new track once the weather improves. We can remove any micro-tracks that are less than three days.
Specify a duration, calculate the number of tracks and the number of removed points. Iteratively.
```{r}
##Time is the beginning of the first point.
step_length=8
sxy<-split(mxy,mxy$Animal)
#time diff function
timed<-function(d,step_length){
d$j[1]<-0
for (x in 2:nrow(d)){
d$j[x]<-as.numeric(difftime(as.POSIXct(d$timestamp[x]),as.POSIXct(d$timestamp[x-1]),units="mins"))/(step_length*60)
}
#Split out track endings
ends<-c(1,which(d$j>1),nrow(d))
for(w in 2:length(ends)){
d[ends[w-1]:ends[w],"Track"]<-w-1
}
#remove tracks that are shorter than three days
track_time<-d %>% group_by(Track) %>% summarize(mt=difftime(max(as.POSIXct(timestamp)),min(as.POSIXct(timestamp)),units="hours")) %>% filter(mt>=18) %>% .$Track
d<-d[d$Track %in% track_time,]
#renumber the tracks
d$Track<-as.numeric(as.factor(d$Track))
return(d)
}
sxy<-lapply(sxy,timed,step_length=8)
#Format matrices for jags
mxy<-rbind_all(sxy)
######recode whales
#mxy$Animal<-as.numeric(as.factor(mxy$Animal))
sxy<-split(mxy,list(mxy$Animal,mxy$Track),drop=TRUE)
sxy<-lapply(sxy,function(x){
#How many observations in each step length segment
x$Step<-as.numeric(cut(as.POSIXct(x$timestamp),"8 hours"))
return(x)
})
mxy<-rbind_all(sxy)
#refactor animal
mxy$Animal<-as.numeric(as.factor(mxy$Animal))
```
```{r}
#total number of steps per track/animal
steps_all<-mxy %>% group_by(Animal,Track) %>% summarize(n=length(unique(Step)))
# give each step a label
mxy<-mxy %>% group_by(Animal,Track,Step) %>% mutate(jStep=1:n())
#Cast time array
j<-acast(mxy,Animal~Track~Step~jStep,value.var="j")
#how many observations per individual in each Step
mxy$Step<-factor(mxy$Step,levels=1:max(steps_all$n))
idx<-melt(table(mxy$Animal,mxy$Track,mxy$Step))
colnames(idx)<-c("Animal","Track","Step","jStep")
idx<-acast(data=idx,Animal~Track~Step)
#make ocean a matrix -> MEAN VALUE -> will this yield a jags error on empty cells?
oc<-acast(mxy,Animal~Track~Step,value.var="ocean",fun.aggregate = mean)
#make coast a matrix -> MEAN VALUE
coast<-acast(mxy,Animal~Track~Step,value.var="coast",fun.aggregate = mean)
#month array
mxy$MonthF<-as.numeric(factor(mxy$Month,levels=month.name))
MonthA<-acast(mxy,Animal~Track~Step,value.var="MonthF",fun.aggregate = min)
MonthA[!is.finite(MonthA)]<-NA
#Individuals
ind=length(unique(mxy$Animal))
#tracks per indivudal
tracks<-mxy %>% group_by(Animal) %>% summarize(tracks=length(unique(Track))) %>% .$tracks
#steps per track
steps<-acast(steps_all,Animal~Track,value.var="n")
#obs array
obs<-melt(mxy,measure.vars=c("x","y"))
obs<-acast(obs,Animal~Track~Step~jStep~variable)
```
How did the filter change the extent of tracks?
```{r}
#Plot
mxy<-mxy %>% arrange(Animal,Track,Step,jStep)
pp<-c(mean(mxy$x),mean(mxy$y))
m <- get_map(location=pp,source="google",zoom=5,scale=2,maptype="satellite",color = "bw")
ggmap(m)+geom_path(data=mxy, aes(x=x, y=y,col=as.factor(Animal)),size=.5) + scale_color_discrete(guide="none") + theme_inset()
```
```{r,fig.height=15}
ggplot() +  geom_path(data=oxy,col='blue',aes(x=x,y=y)) +  geom_path(data=mxy,col='red',aes(x=x,y=y),size=2,alpha=0.7)  + facet_wrap(~individual.local.identifier,scales="free",ncol=4)
```
```{r,fig.height=3,fig.width=5}
ggplot(data=steps_all,aes(x=n*step_length/24)) + geom_histogram() + labs(x="Days") + ggtitle("Track Length")
ggplot(data=steps_all,aes(x=Track)) + geom_histogram() + labs(x="Subtracks per Animal")
```
#bind chains
pc<-melt(jagM$BUGSoutput$sims.array)
colnames(pc)<-c("Draw","chain","par","value")
#extract parameter name
pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
#Extract index
splitpc<-split(pc,pc$parameter)
#single index
splitpc[c("alpha_mu","beta_mu","beta2_mu","gamma","theta")]<-lapply(splitpc[c("alpha_mu","beta_mu","beta2_mu","gamma","theta")],function(x){
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
pc<-data.frame(x,Behavior=sv)
return(pc)
})
## double index
splitpc[c("beta","beta2")]<-lapply(splitpc[c("beta","beta2")],function(x){
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
colnames(sv)<-c("MonthF","Behavior")
pc<-data.frame(x,sv)
#get month name
mindex<-mxy %>% select(MonthF,Month) %>% distinct()
pc<-merge(pc,mindex,by="MonthF")
return(pc)
})
#State index
splitpc[c("state")]<-lapply(splitpc[c("state")],function(x){
#As matrices
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+)]"))[,3:5]
colnames(sv)<-c("Animal","Track","step")
pc<-data.frame(x,sv)
})
#Three index
splitpc[c("phi")]<-lapply(splitpc[c("phi")],function(x){
#As matrices
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+),(\\d+)]"))[,3:6]
colnames(sv)<-c("Animal","Track","step","Behavior")
pc<-data.frame(x,sv)
})
#bind all matrices back together
pc<-rbind_all(splitpc)
rm(splitpc)
postplot_alpha<-pc %>% filter(parameter %in% c('alpha_mu')) %>% do(dcast(.,Draw+chain~par))
postplot_beta<-pc %>% filter(parameter %in% c('beta')) %>% dcast(.,Month+Draw+chain~parameter+Behavior)
#bind chains
pc<-melt(jagM$BUGSoutput$sims.array)
colnames(pc)<-c("Draw","chain","par","value")
#extract parameter name
pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
#Extract index
splitpc<-split(pc,pc$parameter)
#single index
splitpc[c("alpha_mu","beta_mu","beta2_mu","gamma","theta")]<-lapply(splitpc[c("alpha_mu","beta_mu","beta2_mu","gamma","theta")],function(x){
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
pc<-data.frame(x,Behavior=sv)
return(pc)
})
## double index
splitpc[c("beta","beta2")]<-lapply(splitpc[c("beta","beta2")],function(x){
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
colnames(sv)<-c("MonthF","Behavior")
pc<-data.frame(x,sv)
#get month name
mindex<-mxy %>% select(MonthF,Month) %>% distinct()
pc<-merge(pc,mindex,by="MonthF")
return(pc)
})
#State index
splitpc[c("state")]<-lapply(splitpc[c("state")],function(x){
#As matrices
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+)]"))[,3:5]
colnames(sv)<-c("Animal","Track","step")
pc<-data.frame(x,sv)
})
#Three index
splitpc[c("phi")]<-lapply(splitpc[c("phi")],function(x){
#As matrices
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+),(\\d+)]"))[,3:6]
colnames(sv)<-c("Animal","Track","step","Behavior")
pc<-data.frame(x,sv)
})
#bind all matrices back together
pc<-rbind_all(splitpc)
rm(splitpc)
head(pc)
postplot_alpha<-pc %>% filter(parameter %in% c('alpha_mu')) %>% do(dcast(.,Draw+chain~par))
postplot_beta<-pc %>% filter(parameter %in% c('beta')) %>% dcast(.,Month+Draw+chain~parameter+Behavior)
postplot_beta<-pc %>% filter(parameter %in% c('beta'))
pc %>% filter(parameter %in% c('beta'))
#bind chains
pc<-melt(jagM$BUGSoutput$sims.array)
colnames(pc)<-c("Draw","chain","par","value")
#extract parameter name
pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
#Extract index
splitpc<-split(pc,pc$parameter)
#single index
splitpc[c("alpha_mu","beta_mu","beta2_mu","gamma","theta")]<-lapply(splitpc[c("alpha_mu","beta_mu","beta2_mu","gamma","theta")],function(x){
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
pc<-data.frame(x,Behavior=sv)
return(pc)
})
## double index
splitpc[c("beta","beta2")]<-lapply(splitpc[c("beta","beta2")],function(x){
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
colnames(sv)<-c("MonthF","Behavior")
pc<-data.frame(x,sv)
#get month name
mindex<-mxy %>% select(MonthF,Month) %>% distinct()
pc<-merge(pc,mindex,by="MonthF")
return(pc)
})
#State index
splitpc[c("state")]<-lapply(splitpc[c("state")],function(x){
#As matrices
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+)]"))[,3:5]
colnames(sv)<-c("Animal","Track","step")
pc<-data.frame(x,sv)
})
#Three index
splitpc[c("phi")]<-lapply(splitpc[c("phi")],function(x){
#As matrices
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+),(\\d+)]"))[,3:6]
colnames(sv)<-c("Animal","Track","step","Behavior")
pc<-data.frame(x,sv)
})
#bind all matrices back together
pc<-rbind_all(splitpc)
rm(splitpc)
head(pc)
tail(pc)
pc %>% filter(parameter=="beta2")
pc<-melt(jagM$BUGSoutput$sims.array)
colnames(pc)<-c("Draw","chain","par","value")
#extract parameter name
pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
pc %>% filter(parameter=="beta")
haed(pc %>% filter(parameter=="beta"))
head(pc %>% filter(parameter=="beta"))
## double index
splitpc[c("beta","beta2")]<-lapply(splitpc[c("beta","beta2")],function(x){
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
colnames(sv)<-c("MonthF","Behavior")
setp<-data.frame(x,sv)
#get month name
mindex<-mxy %>% select(MonthF,Month) %>% distinct()
setp<-merge(setp,mindex,by="MonthF")
return(setp)
})
pc<-melt(jagM$BUGSoutput$sims.array)
colnames(pc)<-c("Draw","chain","par","value")
#extract parameter name
pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
#Extract index
splitpc<-split(pc,pc$parameter)
## double index
splitpc[c("beta","beta2")]<-lapply(splitpc[c("beta","beta2")],function(x){
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
colnames(sv)<-c("MonthF","Behavior")
setp<-data.frame(x,sv)
#get month name
mindex<-mxy %>% select(MonthF,Month) %>% distinct()
setp<-merge(setp,mindex,by="MonthF")
return(setp)
})
splitpc[c("beta","beta2")][[1]]
splitpc[c("beta","beta2")]
splitpc[c("beta","beta2")][[1]]
pc<-melt(jagM$BUGSoutput$sims.array)
colnames(pc)<-c("Draw","chain","par","value")
pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
#Extract index
splitpc<-split(pc,pc$parameter)
splitpc[c("beta","beta2")][[1]]
x<-splitpc[c("beta","beta2")][[1]]
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
head(sv)
colnames(sv)<-c("MonthF","Behavior")
setp<-data.frame(x,sv)
head(setp)
mindex<-mxy %>% select(MonthF,Month) %>% distinct()
mindex
mindex<-mxy %>% select(MonthF,Month) %>% distinct()
mindex
mxy %>% select(MonthF,Month)
mindex<-mxy %>% ungroup() %>% select(MonthF,Month) %>% distinct()
mindex
#bind chains
pc<-melt(jagM$BUGSoutput$sims.array)
colnames(pc)<-c("Draw","chain","par","value")
#extract parameter name
pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
#Extract index
splitpc<-split(pc,pc$parameter)
#single index
splitpc[c("alpha_mu","beta_mu","beta2_mu","gamma","theta")]<-lapply(splitpc[c("alpha_mu","beta_mu","beta2_mu","gamma","theta")],function(x){
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
pc<-data.frame(x,Behavior=sv)
return(pc)
})
## double index
splitpc[c("beta","beta2")]<-lapply(splitpc[c("beta","beta2")],function(x){
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
colnames(sv)<-c("MonthF","Behavior")
setp<-data.frame(x,sv)
#get month name
mindex<-mxy %>% ungroup() %>% select(MonthF,Month) %>% distinct()
setp<-merge(setp,mindex,by="MonthF")
return(setp)
})
#State index
splitpc[c("state")]<-lapply(splitpc[c("state")],function(x){
#As matrices
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+)]"))[,3:5]
colnames(sv)<-c("Animal","Track","step")
pc<-data.frame(x,sv)
})
#Three index
splitpc[c("phi")]<-lapply(splitpc[c("phi")],function(x){
#As matrices
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+),(\\d+)]"))[,3:6]
colnames(sv)<-c("Animal","Track","step","Behavior")
pc<-data.frame(x,sv)
})
#bind all matrices back together
pc<-rbind_all(splitpc)
rm(splitpc)
head(pc)
library(knitr)
opts_chunk$set(echo=F,warning=F,message=F,fig.width = 11,fig.height = 5)
library(boot)
library(raster)
library(reshape2)
library(ggplot2)
library(survival)
library(MASS)
library(ggmap)
library(dplyr)
library(chron)
library(gridExtra)
library(stringr)
library(R2jags)
library(move)
#New model to be run, flag turned off if just updating.
newModel<-T
distc<-raster("InputData/dist2coast-2015.tif")
plot(distc)
library(maps)
map()
plot(distc)
map(add=T)
plot(distc)
plot(distc)
map(add=T)
dplot
load("SingleSpecies.RData")
dplot
postplot<-pc %>% filter(parameter %in% c('beta2_mu','alpha_mu')) %>% dcast(.,Draw+chain~par) %>% group_by(Draw,chain) %>% do(dplot(a1=c(.$'alpha_mu[1]',.$'alpha_mu[2]'),beta2=c(.$'beta2_mu[1]',.$'beta2_mu[2]'),coast=unique(mxy$coast)))
warnings()
head(postplot)
postplot<-pc %>% filter(parameter %in% c('beta2_mu','alpha_mu')) %>% dcast(.,Draw+chain~par) %>% group_by(Draw,chain) %>% do(dplot(a1=c(.$'alpha_mu[1]',.$'alpha_mu[2]'),beta2=c(.$'beta2_mu[1]',.$'beta2_mu[2]'),coast=unique(mxy$coast))) %>% group_by(coast,Begin,State) %>% summarize(mean=mean(y),lower=quantile(y,0.05),upper=quantile(y,0.95))
poltplot
postplot
ggplot(postplot) + geom_ribbon(aes(x=coast,y=mean,ymin=upper,ymax=lower,fill=State),alpha=0.5) + theme_bw() + labs(col="Transition",x="Distance to Coast (km)",y="Probability",fill="Transition") + facet_wrap(~Begin) + xlim(0,quantile(mxy$coast,0.5))
postplot_alpha<-pc %>% filter(parameter %in% c('alpha_mu')) %>% do(dcast(.,Draw+chain~par))
postplot_beta<-pc %>% filter(parameter %in% c('beta2')) %>% dcast(.,Month+Draw+chain~parameter+Behavior)
#bind chains
pc<-melt(jagM$BUGSoutput$sims.array)
colnames(pc)<-c("Draw","chain","par","value")
#extract parameter name
pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
#Extract index
splitpc<-split(pc,pc$parameter)
#single index
splitpc[c("alpha_mu","beta_mu","beta2_mu","gamma","theta")]<-lapply(splitpc[c("alpha_mu","beta_mu","beta2_mu","gamma","theta")],function(x){
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
pc<-data.frame(x,Behavior=sv)
return(pc)
})
## double index
splitpc[c("beta","beta2")]<-lapply(splitpc[c("beta","beta2")],function(x){
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
colnames(sv)<-c("MonthF","Behavior")
setp<-data.frame(x,sv)
#get month name
mindex<-mxy %>% ungroup() %>% select(MonthF,Month) %>% distinct()
setp<-merge(setp,mindex,by="MonthF")
return(setp)
})
#State index
splitpc[c("state")]<-lapply(splitpc[c("state")],function(x){
#As matrices
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+)]"))[,3:5]
colnames(sv)<-c("Animal","Track","step")
pc<-data.frame(x,sv)
})
#Three index
splitpc[c("phi")]<-lapply(splitpc[c("phi")],function(x){
#As matrices
sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+),(\\d+)]"))[,3:6]
colnames(sv)<-c("Animal","Track","step","Behavior")
pc<-data.frame(x,sv)
})
#bind all matrices back together
pc<-rbind_all(splitpc)
rm(splitpc)
postplot_alpha<-pc %>% filter(parameter %in% c('alpha_mu')) %>% do(dcast(.,Draw+chain~par))
postplot_beta<-pc %>% filter(parameter %in% c('beta2')) %>% dcast(.,Month+Draw+chain~parameter+Behavior)
postall<-merge(postplot_alpha,postplot_beta,by=c("Draw","chain"))
head(postall)
allplot<-postall %>% group_by(Month,Draw,chain) %>% do(dplot(a1=c(.$'alpha_mu[1]',.$'alpha_mu[2]'),beta=c(.$'beta2_1',.$'beta2_2'),x=0,coast=unique(mxy$coast))) %>% group_by(x=coast,Month,Begin,State) %>% summarize(mean=mean(y),lower=quantile(y,0.05),upper=quantile(y,0.95))
allplot$Month<-factor(allplot$Month,levels=month.name)
ggplot(allplot) + geom_ribbon(aes(x=x,y=mean,ymin=upper,ymax=lower,fill=Month),alpha=0.5) + theme_bw() + labs(col="Transition",x="Distance to Coast (km)",y="Probability",fill="Transition") + facet_grid(State~Begin)+ xlim(0,quantile(mxy$coast,0.5))
allplot<-postall %>% group_by(Month,Draw,chain) %>% do(dplot(a1=c(.$'alpha_mu[1]',.$'alpha_mu[2]'),beta=c(.$'beta2_1',.$'beta2_2'),x=0,coast=unique(mxy$coast))) %>% group_by(coast,Month,Begin,State) %>% summarize(mean=mean(y),lower=quantile(y,0.05),upper=quantile(y,0.95))
allplot$Month<-factor(allplot$Month,levels=month.name)
ggplot(allplot) + geom_ribbon(aes(x=x,y=mean,ymin=upper,ymax=lower,fill=Month),alpha=0.5) + theme_bw() + labs(col="Transition",x="Distance to Coast (km)",y="Probability",fill="Transition") + facet_grid(State~Begin)+ xlim(0,quantile(mxy$coast,0.5))
xlim(0,quantile(mxy$coast,0.5))
head(allplot)
allplot$mean
postplot_alpha<-pc %>% filter(parameter %in% c('alpha_mu')) %>% do(dcast(.,Draw+chain~par))
postplot_beta<-pc %>% filter(parameter %in% c('beta2')) %>% dcast(.,Month+Draw+chain~parameter+Behavior)
allplot<-postall %>% group_by(Month,Draw,chain) %>% do(dplot(a1=c(.$'alpha_mu[1]',.$'alpha_mu[2]'),beta=c(.$'beta2_1',.$'beta2_2'),x=0,coast=unique(mxy$coast))) %>% group_by(coast,Month,Begin,State) %>% summarize(mean=mean(y),lower=quantile(y,0.05),upper=quantile(y,0.95))
postall<-merge(postplot_alpha,postplot_beta,by=c("Draw","chain"))
allplot$Month<-factor(allplot$Month,levels=month.name)
ggplot(allplot) + geom_ribbon(aes(x=x,y=mean,ymin=upper,ymax=lower,fill=Month),alpha=0.5) + theme_bw() + labs(col="Transition",x="Distance to Coast (km)",y="Probability",fill="Transition") + facet_grid(State~Begin)+ xlim(0,quantile(mxy$coast,0.5))
ggplot(allplot) + geom_ribbon(aes(x=coast,y=mean,ymin=upper,ymax=lower,fill=Month),alpha=0.5) + theme_bw() + labs(col="Transition",x="Distance to Coast (km)",y="Probability",fill="Transition") + facet_grid(State~Begin)+ xlim(0,quantile(mxy$coast,0.5))
postplot_alpha<-pc %>% filter(parameter %in% c('alpha_mu')) %>% do(dcast(.,Draw+chain~par))
postplot_beta<-pc %>% filter(parameter %in% c('beta2')) %>% dcast(.,Month+Draw+chain~parameter+Behavior)
postall<-merge(postplot_alpha,postplot_beta,by=c("Draw","chain"))
allplot<-postall %>% group_by(Month,Draw,chain) %>% do(dplot(a1=c(.$'alpha_mu[1]',.$'alpha_mu[2]'),beta=c(.$'beta2_1',.$'beta2_2'),coast=unique(mxy$coast))) %>% group_by(coast,Month,Begin,State) %>% summarize(mean=mean(y),lower=quantile(y,0.05),upper=quantile(y,0.95))
allplot$Month<-factor(allplot$Month,levels=month.name)
allplot$Month
ggplot(allplot) + geom_ribbon(aes(x=coast,y=mean,ymin=upper,ymax=lower,fill=Month),alpha=0.5) + theme_bw() + labs(col="Transition",x="Distance to Coast (km)",y="Probability",fill="Transition") + facet_grid(State~Begin)+ xlim(0,quantile(mxy$coast,0.5))
haed(allplot)
head(allplot)
allplot$coast
hist(allplot$coast)
dplot
postplot_alpha<-pc %>% filter(parameter %in% c('alpha_mu')) %>% do(dcast(.,Draw+chain~par))
postplot_beta<-pc %>% filter(parameter %in% c('beta2')) %>% dcast(.,Month+Draw+chain~parameter+Behavior)
head(postplot-beta)
head(postplot_beta)
#get the posterior estimates of the env function
postplot_alpha<-pc %>% filter(parameter %in% c('alpha_mu')) %>% do(dcast(.,Draw+chain~par))
postplot_beta<-pc %>% filter(parameter %in% c('beta2')) %>% dcast(.,Month+Draw+chain~parameter+Behavior)
postall<-merge(postplot_alpha,postplot_beta,by=c("Draw","chain"))
allplot<-postall %>% group_by(Month,Draw,chain) %>% do(dplot(a1=c(.$'alpha_mu[1]',.$'alpha_mu[2]'),beta2=c(.$'beta2_1',.$'beta2_2'),coast=unique(mxy$coast))) %>% group_by(coast,Month,Begin,State) %>% summarize(mean=mean(y),lower=quantile(y,0.05),upper=quantile(y,0.95))
allplot$Month<-factor(allplot$Month,levels=month.name)
ggplot(allplot) + geom_ribbon(aes(x=coast,y=mean,ymin=upper,ymax=lower,fill=Month),alpha=0.5) + theme_bw() + labs(col="Transition",x="Distance to Coast (km)",y="Probability",fill="Month") + facet_grid(State~Begin)+ xlim(0,quantile(mxy$coast,0.5))
#mean env estimate
ggplot(allplot) + geom_ribbon(aes(x=coast,y=mean,ymin=upper,ymax=lower,fill=Month),alpha=0.5) + theme_bw() + labs(col="Transition",x="Distance to Coast (km)",y="Probability",fill="Month") + facet_grid(State~Begin)
ggplot(allplot[allplot$Begin=="Traveling" & allplot$State == "Foraging",]) + geom_ribbon(aes(x=x,y=mean,ymin=upper,ymax=lower,fill=Month),alpha=0.5,size=1) + theme_bw() + labs(col="Transition",x="Ocean Depth (km)",y="Probability of Feeding",fill="Month") + xlim(0,quantile(mxy$coast,0.5))
ggplot(allplot[allplot$Begin=="Traveling" & allplot$State == "Foraging",]) + geom_ribbon(aes(x=coast,y=mean,ymin=upper,ymax=lower,fill=Month),alpha=0.5,size=1) + theme_bw() + labs(col="Transition",x="Ocean Depth (km)",y="Probability of Feeding",fill="Month") + xlim(0,quantile(mxy$coast,0.5))
ggplot(allplot[allplot$Begin=="Traveling" & allplot$State == "Foraging",]) + geom_ribbon(aes(x=x,y=mean,ymin=upper,ymax=lower,fill=Month),alpha=0.5,size=1) + theme_bw() + labs(col="Transition",x="Ocean Depth (km)",y="Probability of Switching",fill="Month")
ggplot(allplot[allplot$Begin=="Traveling" & allplot$State == "Foraging",]) + geom_line(aes(x=coast,y=mean,ymin=upper,ymax=lower,col=Month),alpha=0.5,size=1) + theme_bw() + labs(col="Month",x="Ocean Depth (km)",y="Probability of Switching",fill="Month")
ggplot(allplot[allplot$Begin=="Traveling" & allplot$State == "Foraging",]) + geom_line(aes(x=coast,y=mean,ymin=upper,ymax=lower,col=Month),alpha=0.5,size=1) + theme_bw() + labs(col="Transition",x="Ocean Depth (km)",y="Probability of Feeding",fill="Month") + xlim(0,quantile(mxy$coast,0.5))
diffras<-monthras[[1]]-monthras[[5]]
diffdf<-as.data.frame(rasterToPoints(diffras))
plot(diffdf)
plot(diffras)
monthras
stack(monthras)
var(stack(monthras))
sd(stack(monthras))
stack(monthras)
s
sd(s)
var(s)
?calc
calc(s,sd)
calc(stack(monthras),sd)
plot(calc(stack(monthras),sd))
plot(calc(stack(s),sd))
s
s
monthras
#get the posterior estimates of the env function
postplot_alpha<-pc %>% filter(parameter %in% c('alpha_mu')) %>% do(dcast(.,Draw+chain~par))
postplot_beta<-pc %>% filter(parameter %in% c('beta',"beta2")) %>% dcast(.,Month+Draw+chain~parameter+Behavior)
postall<-merge(postplot_alpha,postplot_beta,by=c("Draw","chain"))
postall$Month<-factor(postall$Month,levels=month.name)
Months<-unique(postall$Month)
monthras<-list()
for (x in Months){
monthpar<-postall %>% filter(Month==x)
##Bathymetry
s<-stack(rice,distc)
#Traveling
travpar<-calc(s,function(x){ 1-inv.logit(mean(monthpar$`alpha_mu[1]`) + mean(monthpar$`beta_1` ) * x[1] + mean(monthpar$`beta2_1` * x[2]))})
travdf<-data.frame(rasterToPoints(travpar))
monthras[[x]]<-travpar
}
names(monthras)<-Months
plot(calc(stack(monthras),sd))
plot(calc(stack(monthras),var))
plot(calc(stack(monthras),sd))
plot(varArea<-calc(stack(monthras),sd))
plot(varArea<-calc(stack(monthras),mean))
motnhras
ice<-raster("InputData/ETOPO1_Ice_g_geotiff.tif")
ice<-round(ice*-1/1000,3)
rice<-aggregate(ice,fact=0.1/res(ice))
#coast
distc<-raster("InputData/dist2coast-2015.tif")
rice[rice<0]<-NA
distc[is.na(rice)]<-NA
plot(distc)
mask
?mask
