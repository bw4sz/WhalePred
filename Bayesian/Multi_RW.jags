
    model{
    
    #Constants
    pi <- 3.141592653589
    
    ##argos observation error##
    argos_prec[1:2,1:2] <- inverse(argos_sigma*argos_cov[,])
    
    #Constructing the covariance matrix
    argos_cov[1,1] <- 1
    argos_cov[1,2] <- sqrt(argos_alpha) * rho
    argos_cov[2,1] <- sqrt(argos_alpha) * rho
    argos_cov[2,2] <- argos_alpha
    
    for(i in 1:ind){

    ###First Step###

    ## Priors for first true location -> this is wrong, conflates observation and process error.
    #for lat long
    y[i,1,1:2] ~ dmnorm(argos[i,1,1,1:2],argos_prec)

    #First movement - random walk.
    y[i,2,1:2] ~ dmnorm(y[i,1,1:2],iSigma)
    
    ###First Behavioral State###
    state[i,1] ~ dcat(lambda[]) ## assign state for first obs
    
    #Process Model for movement
    for(t in 2:(steps[i]-1)){
    
    #Behavioral State at time T
    logit(phi[i,t,1]) <- lalpha[i,state[i,t-1]] + lbeta[i,state[i,t-1]] * ocean[i,t]
    phi[i,t,2] <- 1-phi[i,t,1]
    state[i,t] ~ dcat(phi[i,t,])
        
    #Turning covariate
    #Transition Matrix for turning angles
    T[i,t,1,1] <- cos(theta[state[i,t]])
    T[i,t,1,2] <- (-sin(theta[state[i,t]]))
    T[i,t,2,1] <- sin(theta[state[i,t]])
    T[i,t,2,2] <- cos(theta[state[i,t]])
    
    #Correlation in movement change
    d[i,t,1:2] <- y[i,t,] + gamma[state[i,t]] * T[i,t,,] %*% (y[i,t,1:2] - y[i,t-1,1:2])
    
    #Gaussian Displacement
    y[i,t+1,1:2] ~ dmnorm(d[i,t,1:2],iSigma)
    }

    #Final behavior state
    logit(phi[i,steps[i],1]) <- lalpha[i,state[i,steps[i]-1]] + lbeta[i,state[i,steps[i]-1]] * ocean[i,steps[i]]
    phi[i,steps[i],2] <- 1-phi[i,steps[i],1]
    state[i,steps[i]] ~ dcat(phi[i,steps[i],])
    
    ##	Measurement equation - irregular observations
    # loops over regular time intervals (t)    
    
    for(t in 2:steps[i]){					
    
    # loops over observed locations within interval t
    for(u in 1:idx[i,t]){ 
      zhat[i,t,u,1:2] <- (1-j[i,t,u]) * y[i,t-1,1:2] + j[i,t,u] * y[i,t,1:2]

        #for each lat and long
          #argos error
          argos[i,t,u,1:2] ~ dmnorm(zhat[i,t,u,1:2],argos_prec)
        }	
      }
    }
    
    ###Priors###

    #Process Variance
    iSigma ~ dwish(R,2)
    Sigma <- inverse(iSigma)
    
    ##Mean Angle
    tmp[1] ~ dbeta(10, 10)
    tmp[2] ~ dbeta(10, 10)
    
    # prior for theta in 'traveling state'
    theta[1] <- (2 * tmp[1] - 1) * pi
    
    # prior for theta in 'foraging state'    
    theta[2] <- (tmp[2] * pi * 2)
    
    ##Move persistance
    # prior for gamma (autocorrelation parameter) in state 1
    gamma[1] ~ dbeta(5,2)
    
    # prior for gamma in state 2
    gamma[2] ~ dbeta(2,5)
    
    ##Behavioral States
    # Following lunn 2012 p85
    
    #Hierarchical structure
    #Intercepts
    lalpha_mu[1] ~ dnorm(0,0.386)
    lalpha_mu[2] ~ dnorm(0,0.386)

    #Variance
    lalpha_tau[1] ~ dt(0,1,1)I(0,)
    lalpha_tau[2] ~ dt(0,1,1)I(0,)

    #Slopes
    lbeta_mu[1] ~ dnorm(0,0.386)
    lbeta_mu[2] ~ dnorm(0,0.386)

    #Variance
    lbeta_tau[1] ~ dt(0,1,1)I(0,)
    lbeta_tau[2] ~ dt(0,1,1)I(0,)
    
    #For each individual
    for(i in 1:ind){
      # prob of being in state 1 at t, given in state 1 at t-1    
      #Individual Intercept
      lalpha[i,1] ~ dnorm(lalpha_mu[1],lalpha_tau[1])
      logit(alpha[i,1]) <- lalpha[i,1]
      
      #effect of ocean on traveling -> traveling
      lbeta[i,1] ~ dnorm(lbeta_mu[1],lbeta_tau[1])
      logit(beta[i,1]) <- lbeta[i,1]
  
      #Prob of transition to state 1 given state 2 at t-1
      lalpha[i,2] ~ dnorm(lalpha_mu[2],lalpha_tau[2])
      logit(alpha[i,2]) <- lalpha[i,2]
      
      #effect of ocean on feeding -> traveling
      lbeta[i,2] ~ dnorm(lbeta_mu[2],lbeta_tau[2])
      logit(beta[i,2]) <- lbeta[i,2]
  
    }
    
    #Probability of behavior switching 
    lambda[1] ~ dbeta(1,1)
    lambda[2] <- 1 - lambda[1]

    ##Argos priors##
    argos_alpha~dgamma(0.0001,0.0001)
    rho ~ dunif(-1, 1)
    argos_sigma ~ dgamma(0.0001,0.0001)

    }
