---
title: "Priors for Dynamic Correlated Random Walk (Jonsen 2016)"
author: "Ben Weinstein"
date: "May 9th, 2016"
output: 
  html_document:
    keep_md: True
  numbered_sections: True
  toc: true
  theme: spacelab
---

```{r,warning=FALSE,message=FALSE,echo=FALSE}
library(knitr)
opts_chunk$set(echo=F,warning=F,message=F,fig.width = 10,fig.height = 5)
library(sp)
library(dismo)
library(potools)
library(raster)
library(reshape2)
library(ggplot2)
library(MASS)
library(dplyr)
library(chron)
library(moveHMM)
library(move)
library(ggmap)
library(maps)
library(gridExtra)
library(stringr)
library(rjags)

#New model to be run, flag turned off if just updating.
newModel<-T

#Source Jonsen 2016
source("Jonsen2016.R")
```

```{r,eval=F}
#Load in data
load("HMM.RData")
jags$recompile()
newModel<-F
```

#Correlated random walk

*Process Model*

$$ d_{t} \sim T*d_{t-1} + Normal(0,\Sigma)$$
$$ x_t = x_{t-1} + d_{t} $$

## Parameters

$$\theta = \text{Mean turning angle}$$
$$\gamma = \text{Move persistence} $$


###Behavioral States
$$ 1 = \text{traveling}$$
$$ 2 = \text{foraging}$$

#Simulation

##Behavioral States
$$ \alpha_{1,1} = \text{High probability of remaining traveling when traveling)} = 0.9$$
$$\alpha_{2,1} = \text{Low probability of switching from feeding to traveling} = 0.2$$

Essentially, whales travel long straight distances to find food sources, but then stay in those patches for a long time. 

From these probabilities we can compute the full transition matrix.

$$\begin{matrix}
  \alpha_{1,1} & 1-\alpha_{1,1} \\
  \alpha_{2,1} & 1-\alpha_{2,1} \\
\end{matrix}
$$

## Traveling
$$\gamma_1 = 0.9 = \text{Strong Movement Persistence}$$
$$\theta_1 = 0 = \text{No preference in turns}$$

## Foraging
$$\gamma_2 = 0.1 = \text{Weak Movement Persistence}$$
$$\theta_2 = pi = \text{Many reversals in turns}$$

For both behaviors process variance is:
$$ \sigma_{latitude} = 0.1$$
$$ \sigma_{longitude} = 0.1$$

Values come from Jonsen (2005) and Jonsen (2016) fit for foraging seals.

```{r}
gamma=c(0.9,0.1)
theta=c(0,pi)
a1=c(0.9,0.2)

#Use Jonsen 2016 function to simulate
if(newModel){
  #dxy<-traj(gamma=gamma,theta=theta,a1=a1)  
  dxy<-simTrack(gamma=gamma,theta = theta,alpha=a1)
  dxy$Step<-1:nrow(dxy)
}

ggplot(dxy,aes(x=x,y=y)) + geom_point(size=2,col='black') + geom_path(aes(col=Step),size=2) + scale_color_continuous(low='blue',high='red') + theme_bw()
```

### Multiple trajectories.
```{r}
mxy<-lapply(1:10,function(x) simTrack(gamma=gamma,theta=theta,alpha=a1))
mxy<-melt(mxy,id.vars=c("x","y","Step"))
ggplot(mxy,aes(x=x,y=y)) + geom_path(aes(col=as.factor(L1)),size=2) + theme_bw() + scale_color_discrete(guide=F) + ggtitle("Multiple trajectories")
```

#Uninformative Priors

```{r}
hist(rbeta(1e5,1,1),main='gamma')
hist(rbeta(1e5,1,1),main='theta')
```{r,eval=T}
#source model
source("Bayesian/HMMvague.R")

#print model
print.noquote(readLines("Bayesian/HMMvague.R"))

#prior shape
R <- diag(c(1,1))
#data=list(y=cbind(dxy$x,dxy$y),steps=nrow(dxy),R=R)

if(newModel){
  jags<-jags.model(file = "Bayesian/HMMvague.jags",data=data,n.chains=2)
  }

system.time(update(jags,15000))
p<-coda.samples(model=jags,n.iter=1000,thin=10,variable.names=c("theta","gamma","alpha"))
```

##Chains
```{r,fig.height=5}
potrace(p)
```

##Posteriors

```{r}
#true values
tv<-melt(list('alpha[1]'=a1[1],'alpha[2]'=a1[2],'theta[2]'=theta[2],'theta[1]'=theta[1],'gamma[1]'=gamma[1],'gamma[2]'=gamma[2]))
colnames(tv)<-c("value","par")

#bind chains
out<-rbind(p[[1]],p[[2]])
pc<-melt(out)
colnames(pc)<-c("Draw","par","value")

#Plot
ggplot(data=pc,aes(x=value)) + geom_histogram() + facet_wrap(~par,scales='free',ncol=4) + theme_bw() + geom_vline(data=tv,aes(xintercept=value),col='red',linetype='dashed') + ggtitle("Estimated parameters, true values in red")
```

##Prediction - no error

```{r,eval=F}
pr<-coda.samples(model=jags,n.iter=1000,n.thin=5,variable.names=c("d"))
ps<-rbind(pr[[1]],pr[[2]])
ps<-melt(ps)

#extract positions
sv<-data.frame(str_match(ps$Var2,"(\\w+)\\[(\\d+),(\\d+)]"))[,-1]
colnames(sv)<-c("par","step","xy")

#format to combine
ps<-data.frame(ps,sv)
#relevel
levels(ps$xy)<-c("x","y")

#levels(ps$Var2)<-c("mean","lower","median","upper","Rhat")

#Just keep mean, upper and lower
toplot<-dcast(ps,Var1+step~xy,value.var = "value")
sumplot<-group_by(toplot,step) %>% summarize(x_mean=mean(x),y_mean=mean(y))

#arrange by step
sumplot$step<-as.numeric(as.character(sumplot$step))
sumplot<-sumplot %>% arrange(step)

ggplot(sumplot,aes(x=x_mean,y=y_mean)) + geom_path(size=2,alpha=0.5) + theme_bw() + geom_path(data=dxy,aes(x=x,y=y),col='red') + ggtitle("Predicted path (black) compared to true path (red)") 

#+ geom_path(aes(x=x_lower,y=y_lower),linetype='dashed') + #geom_path(aes(x=x_upper,y=y_upper),linetype='dashed')
```

Point Density

```{r,eval=F}
out<-rbind(pr[[1]],pr[[2]])
pc<-melt(out)
colnames(pc)<-c("Draw","param","value")

sv<-data.frame(str_match(pc$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,-1]
colnames(sv)<-c("par","step","xy")

#format to combine
pc<-data.frame(pc,sv)
#relevel
levels(pc$xy)<-c("x","y")
toplot<-dcast(pc,Draw+step~xy,value.var = "value")

#arrange by step
toplot$step<-as.numeric(as.character(toplot$step))
toplot<-toplot %>% arrange(step)

ggplot(data=toplot,aes(x=x,y=y,col=step)) + geom_point() + theme_bw()
```

```{r}
save.image("HMM.RData")
```
